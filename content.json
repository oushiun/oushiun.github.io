{"meta":{"title":"oushiun","subtitle":null,"description":"互联网产品、技术、设计文章分享","author":"oushiun","url":"http://oushiun.com"},"pages":[{"title":"About","date":"2018-05-15T02:26:48.272Z","updated":"2018-05-15T02:26:48.272Z","comments":false,"path":"about/index.html","permalink":"http://oushiun.com/about/index.html","excerpt":"","text":"玩物丧志 其志小志大者 玩物养志"},{"title":"Categories","date":"2018-05-09T03:07:44.547Z","updated":"2018-05-09T03:07:44.547Z","comments":false,"path":"categories/index.html","permalink":"http://oushiun.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-09T03:07:48.749Z","updated":"2018-05-09T03:07:48.749Z","comments":false,"path":"tags/index.html","permalink":"http://oushiun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Kotlin 1.1 的新特性","slug":"kotlin-whatsnew1.1","date":"2018-05-15T03:23:01.000Z","updated":"2018-05-15T03:37:45.968Z","comments":true,"path":"2018/05/15/kotlin-whatsnew1.1/","link":"","permalink":"http://oushiun.com/2018/05/15/kotlin-whatsnew1.1/","excerpt":"协程（实验性的）Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 协程实际上是一个轻量级的线程，可以挂起并稍后恢复。协程通过挂起函数支持：对这样的函数的调用可能会挂起协程，并启动一个新的协程，我们通常使用匿名挂起函数（即挂起 lambda 表达式）。","text":"协程（实验性的）Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 协程实际上是一个轻量级的线程，可以挂起并稍后恢复。协程通过挂起函数支持：对这样的函数的调用可能会挂起协程，并启动一个新的协程，我们通常使用匿名挂起函数（即挂起 lambda 表达式）。 我们来看看在外部库 kotlinx.coroutines 中实现的 async/await： 12345678910111213141516// 在后台线程池中运行该代码fun asyncOverlay() = async(CommonPool) &#123; // 启动两个异步操作 val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // 然后应用叠加到两个结果 applyOverlay(original.await(), overlay.await())&#125;// 在 UI 上下文中启动新的协程launch(UI) &#123; // 等待异步叠加完成 val image = asyncOverlay().await() // 然后在 UI 中显示 showImage(image)&#125; 这里，async { …… } 启动一个协程，当我们使用 await() 时，挂起协程的执行，而执行正在等待的操作，并且在等待的操作完成时恢复（可能在不同的线程上） 。 标准库通过 yield 和 yieldAll 函数使用协程来支持惰性生成序列。在这样的序列中，在取回每个元素之后挂起返回序列元素的代码块，并在请求下一个元素时恢复。这里有一个例子： 1234567891011121314151617import kotlin.coroutines.experimental.*fun main(args: Array&lt;String&gt;) &#123;//sampleStart val seq = buildSequence &#123; for (i in 1..5) &#123; // 产生一个 i 的平方 yield(i * i) &#125; // 产生一个区间 yieldAll(26..28) &#125; // 输出该序列 println(seq.toList())//sampleEnd&#125; 更多信息请参见协程文档及教程。 请注意，协程目前还是一个实验性的功能，这意味着 Kotlin 团队不承诺在最终的 1.1 版本时保持该功能的向后兼容性。 其他语言功能类型别名类型别名允许你为现有类型定义备用名称。这对于泛型类型（如集合）以及函数类型最有用。这里有几个例子： 123456789101112131415161718192021222324252627//sampleStarttypealias OscarWinners = Map&lt;String, String&gt;fun countLaLaLand(oscarWinners: OscarWinners) = oscarWinners.count &#123; it.value.contains(\"La La Land\") &#125;// 请注意，类型名称（初始名和类型别名）是可互换的：fun checkLaLaLandIsTheBestMovie(oscarWinners: Map&lt;String, String&gt;) = oscarWinners[\"Best picture\"] == \"La La Land\"//sampleEndfun oscarWinners(): OscarWinners &#123; return mapOf( \"Best song\" to \"City of Stars (La La Land)\", \"Best actress\" to \"Emma Stone (La La Land)\", \"Best picture\" to \"Moonlight\" /* …… */)&#125;fun main(args: Array&lt;String&gt;) &#123; val oscarWinners = oscarWinners() val laLaLandAwards = countLaLaLand(oscarWinners) println(\"LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.\") val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners) println(\"LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie\")&#125; 更详细信息请参阅其 KEEP。 已绑定的可调用引用现在可以使用 :: 操作符来获取指向特定对象实例的方法或属性的成员引用。以前这只能用 lambda 表达式表示。这里有一个例子： 12345678//sampleStartval numberRegex = \"\\\\d+\".toRegex()val numbers = listOf(\"abc\", \"123\", \"456\").filter(numberRegex::matches)//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"Result is $numbers\")&#125; 更详细信息请参阅其 KEEP。 密封类和数据类Kotlin 1.1 删除了一些对 Kotlin 1.0 中已存在的密封类和数据类的限制。现在你可以在同一个文件中的任何地方定义一个密封类的子类，而不只是以作为密封类嵌套类的方式。数据类现在可以扩展其他类。这可以用来友好且清晰地定义一个表达式类的层次结构： 123456789101112131415161718//sampleStartsealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun eval(expr: Expr): Double = when (expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN&#125;val e = eval(Sum(Const(1.0), Const(2.0)))//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"e is $e\") // 3.0&#125; 更详细信息请参阅其文档或者密封类及数据类的 KEEP。 lambda 表达式中的解构现在可以使用解构声明语法来解开传递给 lambda 表达式的参数。这里有一个例子： 123456789101112fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(1 to \"one\", 2 to \"two\") // 之前 println(map.mapValues &#123; entry -&gt; val (key, value) = entry \"$key -&gt; $value!\" &#125;) // 现在 println(map.mapValues &#123; (key, value) -&gt; \"$key -&gt; $value!\" &#125;)//sampleEnd &#125; 更详细信息请参阅其文档及其 KEEP。 下划线用于未使用的参数对于具有多个参数的 lambda 表达式，可以使用 _ 字符替换不使用的参数的名称： 1234567fun main(args: Array&lt;String&gt;) &#123; val map = mapOf(1 to \"one\", 2 to \"two\")//sampleStart map.forEach &#123; _, value -&gt; println(\"$value!\") &#125;//sampleEnd &#125; 这也适用于解构声明： 12345678910data class Result(val value: Any, val status: String)fun getResult() = Result(42, \"ok\").also &#123; println(\"getResult() returns $it\") &#125;fun main(args: Array&lt;String&gt;) &#123;//sampleStart val (_, status) = getResult()//sampleEnd println(\"status is '$status'\")&#125; 更详细信息请参阅其 KEEP。 数字字面值中的下划线正如在 Java 8 中一样，Kotlin 现在允许在数字字面值中使用下划线来分隔数字分组： 1234567891011//sampleStartval oneMillion = 1_000_000val hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(oneMillion) println(hexBytes.toString(16)) println(bytes.toString(2))&#125; 更详细信息请参阅其 KEEP。 对于属性的更短语法对于没有自定义访问器、或者将 getter 定义为表达式主体的属性，现在可以省略属性的类型： 12345678910//sampleStartdata class Person(val name: String, val age: Int) &#123; val isAdult get() = age &gt;= 20 // 属性类型推断为 “Boolean”&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; val akari = Person(\"Akari\", 26) println(\"$akari.isAdult = $&#123;akari.isAdult&#125;\")&#125; 内联属性访问器如果属性没有幕后字段，现在可以使用 inline 修饰符来标记该属性访问器。这些访问器的编译方式与内联函数相同。 12345678910//sampleStartpublic val &lt;T&gt; List&lt;T&gt;.lastIndex: Int inline get() = this.size - 1//sampleEndfun main(args: Array&lt;String&gt;) &#123; val list = listOf('a', 'b') // 其 getter 会内联 println(\"Last index of $list is $&#123;list.lastIndex&#125;\")&#125; 你也可以将整个属性标记为 inline——这样修饰符应用于两个访问器。 更详细信息请参阅其文档及其 KEEP。 局部委托属性现在可以对局部变量使用委托属性语法。一个可能的用途是定义一个延迟求值的局部变量： 123456789101112131415161718import java.util.Randomfun needAnswer() = Random().nextBoolean()fun main(args: Array&lt;String&gt;) &#123;//sampleStart val answer by lazy &#123; println(\"Calculating the answer...\") 42 &#125; if (needAnswer()) &#123; // 返回随机值 println(\"The answer is $answer.\") // 此时计算出答案 &#125; else &#123; println(\"Sometimes no answer is the answer...\") &#125;//sampleEnd&#125; 更详细信息请参阅其 KEEP。 委托属性绑定的拦截对于委托属性，现在可以使用 provideDelegate 操作符拦截委托到属性之间的绑定。例如，如果我们想要在绑定之前检查属性名称，我们可以这样写： 123456789101112131415class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate(thisRef: MyUI, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, property.name) …… // 属性创建 &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;class MyUI &#123; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 方法在创建 MyUI 实例期间将会为每个属性调用，并且可以立即执行必要的验证。 更详细信息请参阅其文档。 泛型枚举值访问现在可以用泛型的方式来对枚举类的值进行枚举： 1234567891011//sampleStartenum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE&#125; 对于 DSL 中隐式接收者的作用域控制@DslMarker 注解允许限制来自 DSL 上下文中的外部作用域的接收者的使用。考虑那个典型的 HTML 构建器示例： 12345table &#123; tr &#123; td &#123; +\"Text\" &#125; &#125;&#125; 在 Kotlin 1.0 中，传递给 td 的 lambda 表达式中的代码可以访问三个隐式接收者：传递给 table、tr 和 td 的。 这允许你调用在上下文中没有意义的方法——例如在 td 里面调用 tr，从而在 &lt;td&gt; 中放置一个 &lt;tr&gt; 标签。 在 Kotlin 1.1 中，你可以限制这种情况，以使只有在 td 的隐式接收者上定义的方法会在传给 td 的 lambda 表达式中可用。你可以通过定义标记有 @DslMarker 元注解的注解并将其应用于标记类的基类。 更详细信息请参阅其文档及其 KEEP。 rem 操作符mod 操作符现已弃用，而使用 rem 取代。动机参见这个问题。 标准库字符串到数字的转换在 String 类中有一些新的扩展，用来将它转换为数字，而不会在无效数字上抛出异常：String.toIntOrNull(): Int?、 String.toDoubleOrNull(): Double? 等。 1val port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80 还有整数转换函数，如 Int.toString()、 String.toInt()、 String.toIntOrNull()，每个都有一个带有 radix 参数的重载，它允许指定转换的基数（2 到 36）。 onEach()onEach 是一个小、但对于集合和序列很有用的扩展函数，它允许对操作链中的集合/序列的每个元素执行一些操作，可能带有副作用。对于迭代其行为像 forEach 但是也进一步返回可迭代实例。 对于序列它返回一个包装序列，它在元素迭代时延迟应用给定的动作。 1234inputDir.walk() .filter &#123; it.isFile &amp;&amp; it.name.endsWith(\".txt\") &#125; .onEach &#123; println(\"Moving $it to $outputDir\") &#125; .forEach &#123; moveFile(it, File(outputDir, it.toRelativeString(inputDir))) &#125; also()、takeIf() 和 takeUnless()这些是适用于任何接收者的三个通用扩展函数。 also 就像 apply：它接受接收者、做一些动作、并返回该接收者。二者区别是在 apply 内部的代码块中接收者是 this，而在 also 内部的代码块中是 it（并且如果你想的话，你可以给它另一个名字）。当你不想掩盖来自外部作用域的 this 时这很方便： 123456789101112131415161718192021class Block &#123; lateinit var content: String&#125;//sampleStartfun Block.copy() = Block().also &#123; it.content = this.content&#125;//sampleEnd// 使用“apply”代替fun Block.copy1() = Block().apply &#123; this.content = this@copy1.content&#125;fun main(args: Array&lt;String&gt;) &#123; val block = Block().apply &#123; content = \"content\" &#125; val copy = block.copy() println(\"Testing the content was copied:\") println(block.content == copy.content)&#125; takeIf 就像单个值的 filter。它检查接收者是否满足该谓词，并在满足时返回该接收者否则不满足时返回 null。结合 elvis-操作符和及早返回，它允许编写如下结构： 12val outDirFile = File(outputDir.path).takeIf &#123; it.exists() &#125; ?: return false// 对现有的 outDirFile 做些事情 12345678910111213fun main(args: Array&lt;String&gt;) &#123; val input = \"Kotlin\" val keyword = \"in\"//sampleStart val index = input.indexOf(keyword).takeIf &#123; it &gt;= 0 &#125; ?: error(\"keyword not found\") // 对输入字符串中的关键字索引做些事情，鉴于它已找到//sampleEnd println(\"'$keyword' was found in '$input'\") println(input) println(\" \".repeat(index) + \"^\")&#125; takeUnless 与 takeIf 相同，只是它采用了反向谓词。当它 _不_ 满足谓词时返回接收者，否则返回 null。因此，上面的示例之一可以用 takeUnless 重写如下： 1val index = input.indexOf(keyword).takeUnless &#123; it &lt; 0 &#125; ?: error(\"keyword not found\") 当你有一个可调用的引用而不是 lambda 时，使用也很方便： 123456789101112private fun testTakeUnless(string: String) &#123;//sampleStart val result = string.takeUnless(String::isEmpty)//sampleEnd println(\"string = \\\"$string\\\"; result = \\\"$result\\\"\")&#125;fun main(args: Array&lt;String&gt;) &#123; testTakeUnless(\"\") testTakeUnless(\"abc\")&#125; groupingBy()此 API 可以用于按照键对集合进行分组，并同时折叠每个组。 例如，它可以用于计算文本中字符的频率： 123456789101112fun main(args: Array&lt;String&gt;) &#123; val words = \"one two three four five six seven eight nine ten\".split(' ')//sampleStart val frequencies = words.groupingBy &#123; it.first() &#125;.eachCount()//sampleEnd println(\"Counting first letters: $frequencies.\") // 另一种方式是使用“groupBy”和“mapValues”创建一个中间的映射， // 而“groupingBy”的方式会即时计数。 val groupBy = words.groupBy &#123; it.first() &#125;.mapValues &#123; (_, list) -&gt; list.size &#125; println(\"Comparing the result with using 'groupBy': $&#123;groupBy == frequencies&#125;.\")&#125; Map.toMap() 和 Map.toMutableMap()这俩函数可以用来简易复制映射： 123class ImmutablePropertyBag(map: Map&lt;String, Any&gt;) &#123; private val mapCopy = map.toMap()&#125; Map.minus(key)运算符 plus 提供了一种将键值对添加到只读映射中以生成新映射的方法，但是没有一种简单的方法来做相反的操作：从映射中删除一个键采用不那么直接的方式如 Map.filter() 或 Map.filterKeys()。现在运算符 minus 填补了这个空白。有 4 个可用的重载：用于删除单个键、键的集合、键的序列和键的数组。 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(\"key\" to 42) val emptyMap = map - \"key\"//sampleEnd println(\"map: $map\") println(\"emptyMap: $emptyMap\")&#125; minOf() 和 maxOf()这些函数可用于查找两个或三个给定值中的最小和最大值，其中值是原生数字或 Comparable 对象。每个函数还有一个重载，它接受一个额外的 Comparator 实例，如果你想比较自身不可比的对象的话。 1234567891011fun main(args: Array&lt;String&gt;) &#123;//sampleStart val list1 = listOf(\"a\", \"b\") val list2 = listOf(\"x\", \"y\", \"z\") val minSize = minOf(list1.size, list2.size) val longestList = maxOf(list1, list2, compareBy &#123; it.size &#125;)//sampleEnd println(\"minSize = $minSize\") println(\"longestList = $longestList\")&#125; 类似数组的列表实例化函数类似于 Array 构造函数，现在有创建 List 和 MutableList 实例的函数，并通过调用 lambda 表达式来初始化每个元素： 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val squares = List(10) &#123; index -&gt; index * index &#125; val mutable = MutableList(10) &#123; 0 &#125;//sampleEnd println(\"squares: $squares\") println(\"mutable: $mutable\")&#125; Map.getValue()Map 上的这个扩展函数返回一个与给定键相对应的现有值，或者抛出一个异常，提示找不到该键。如果该映射是用 withDefault 生成的，这个函数将返回默认值，而不是抛异常。 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(\"key\" to 42) // 返回不可空 Int 值 42 val value: Int = map.getValue(\"key\") val mapWithDefault = map.withDefault &#123; k -&gt; k.length &#125; // 返回 4 val value2 = mapWithDefault.getValue(\"key2\") // map.getValue(\"anotherKey\") // &lt;- 这将抛出 NoSuchElementException//sampleEnd println(\"value is $value\") println(\"value2 is $value2\")&#125; 抽象集合这些抽象类可以在实现 Kotlin 集合类时用作基类。对于实现只读集合，有 AbstractCollection、 AbstractList、 AbstractSet 和 AbstractMap，而对于可变集合，有 AbstractMutableCollection、 AbstractMutableList、 AbstractMutableSet 和 AbstractMutableMap。在 JVM 上，这些抽象可变集合从 JDK 的抽象集合继承了大部分的功能。 数组处理函数标准库现在提供了一组用于逐个元素操作数组的函数：比较（contentEquals 和 contentDeepEquals），哈希码计算（contentHashCode 和 contentDeepHashCode），以及转换成一个字符串（contentToString 和 contentDeepToString）。它们都支持 JVM（它们作为 java.util.Arrays 中的相应函数的别名）和 JS（在Kotlin 标准库中提供实现）。 1234567fun main(args: Array&lt;String&gt;) &#123;//sampleStart val array = arrayOf(\"a\", \"b\", \"c\") println(array.toString()) // JVM 实现：类型及哈希乱码 println(array.contentToString()) // 良好格式化为列表//sampleEnd&#125; JVM 后端Java 8 字节码支持Kotlin 现在可以选择生成 Java 8 字节码（命令行选项 -jvm-target 1.8 或者 Ant/Maven/Gradle 中的相应选项）。目前这并不改变字节码的语义（特别是，接口和 lambda 表达式中的默认方法的生成与 Kotlin 1.0 中完全一样），但我们计划在以后进一步使用它。 Java 8 标准库支持现在有支持在 Java 7 和 8 中新添加的 JDK API 的标准库的独立版本。如果你需要访问新的 API，请使用 kotlin-stdlib-jre7 和 kotlin-stdlib-jre8 maven 构件，而不是标准的 kotlin-stdlib。这些构件是在 kotlin-stdlib 之上的微小扩展，它们将它作为传递依赖项带到项目中。 字节码中的参数名Kotlin 现在支持在字节码中存储参数名。这可以使用命令行选项 -java-parameters 启用。 常量内联编译器现在将 const val 属性的值内联到使用它们的位置。 可变闭包变量用于在 lambda 表达式中捕获可变闭包变量的装箱类不再具有 volatile 字段。此更改提高了性能，但在一些罕见的使用情况下可能导致新的竞争条件。如果受此影响，你需要提供自己的同步机制来访问变量。 javax.scripting 支持Kotlin 现在与javax.script API（JSR-223）集成。其 API 允许在运行时求值代码段： 123val engine = ScriptEngineManager().getEngineByExtension(\"kts\")!!engine.eval(\"val x = 3\")println(engine.eval(\"x + 2\")) // 输出 5 关于使用 API 的示例项目参见这里。 kotlin.reflect.full为 Java 9 支持准备，在 kotlin-reflect.jar 库中的扩展函数和属性已移动到 kotlin.reflect.full 包中。旧包（kotlin.reflect）中的名称已弃用，将在Kotlin 1.2 中删除。请注意，核心反射接口（如 KClass）是 Kotlin 标准库（而不是 kotlin-reflect）的一部分，不受移动影响。 JavaScript 后端统一的标准库Kotlin 标准库的大部分目前可以从代码编译成 JavaScript 来使用。特别是，关键类如集合（ArrayList、 HashMap 等）、异常（IllegalArgumentException 等）以及其他几个关键类（StringBuilder、 Comparator）现在都定义在 kotlin 包下。在 JVM 平台上，一些名称是相应 JDK 类的类型别名，而在 JS 平台上，这些类在 Kotlin 标准库中实现。 更好的代码生成JavaScript 后端现在生成更加可静态检查的代码，这对 JS 代码处理工具（如 minifiers、 optimisers、 linters 等）更加友好。 external 修饰符如果你需要以类型安全的方式在 Kotlin 中访问 JavaScript 实现的类，你可以使用 external 修饰符写一个 Kotlin 声明。（在 Kotlin 1.0 中，使用了 @native 注解。）与 JVM 目标平台不同，JS 平台允许对类和属性使用 external 修饰符。例如，可以按以下方式声明 DOM Node 类： 123456789external class Node &#123; val firstChild: Node fun appendChild(child: Node): Node fun removeChild(child: Node): Node // 等等&#125; 改进的导入处理现在可以更精确地描述应该从 JavaScript 模块导入的声明。如果在外部声明上添加 @JsModule(&quot;＜模块名＞&quot;) 注解，它会在编译期间正确导入到模块系统（CommonJS或AMD）。例如，使用 CommonJS，该声明会通过 require(……) 函数导入。此外，如果要将声明作为模块或全局 JavaScript 对象导入，可以使用 @JsNonModule 注解。 例如，以下是将 JQuery 导入 Kotlin 模块的方法： 123456789external interface JQuery &#123; fun toggle(duration: Int = definedExternally): JQuery fun click(handler: (Event) -&gt; Unit): JQuery&#125;@JsModule(\"jquery\")@JsNonModule@JsName(\"$\")external fun jquery(selector: String): JQuery 在这种情况下，JQuery 将作为名为 jquery 的模块导入。或者，它可以用作 $-对象，这取决于Kotlin编译器配置使用哪个模块系统。 你可以在应用程序中使用如下所示的这些声明： 12345fun main(args: Array&lt;String&gt;) &#123; jquery(\".toggle-button\").click &#123; jquery(\".toggle-panel\").toggle(300) &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"Kotlin 1.1","slug":"Kotlin-1-1","permalink":"http://oushiun.com/tags/Kotlin-1-1/"}]},{"title":"Kotlin/Native","slug":"kotlin-native-overview","date":"2018-05-15T03:18:04.000Z","updated":"2018-05-15T03:21:58.346Z","comments":true,"path":"2018/05/15/kotlin-native-overview/","link":"","permalink":"http://oushiun.com/2018/05/15/kotlin-native-overview/","excerpt":"Kotlin/Native 是一种将 Kotlin 编译为没有任何虚拟机的原生二进制文件的技术。它包含基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 运行时库的原生实现Kotlin/Native 主要为允许在不希望或不可能使用虚拟机的平台（如 iOS、嵌入式领域等）编译、或者开发人员需要生成不需要额外运行时的合理大小的独立程序而设计的。","text":"Kotlin/Native 是一种将 Kotlin 编译为没有任何虚拟机的原生二进制文件的技术。它包含基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 运行时库的原生实现Kotlin/Native 主要为允许在不希望或不可能使用虚拟机的平台（如 iOS、嵌入式领域等）编译、或者开发人员需要生成不需要额外运行时的合理大小的独立程序而设计的。 Kotlin/Native 完全支持与原生代码的互操作。对于平台库，相应互操作库已可以开箱即用。对于其他库，我们提供了一个由 C 语言头文件生成互操作库的工具，完全支持所有 C 语言功能。在 macOS 与 iOS 上，还支持与 Objective-C 代码互操作。 Kotlin/Native 目前还在开发中；可以试用其预览版。 Kotlin/Native 的 IDE 支持已作为 CLion 及 AppCode 的插件提供，both require the plugin to be installed via Plugins | Install JetBrains plugin… in the IDE preferences。 目标平台Kotlin/Native 目前支持以下平台： Windows（目前只支持 x86_64） Linux（x86_64、 arm32、 MIPS、 MIPS little endian） MacOS（x86_64） iOS（只支持 arm64） Android（arm32 与 arm64） WebAssembly（只支持 wasm32) 示例项目我们已经构建了一些示例项目来展示 Kotlin/Native 的可能性： Kotlin/Native GitHub 版本库包含一些示例项目； KotlinConf Spinner 应用是一个简单的跨平台移动端多人游戏，完全使用 Kotlin/Native 构建，由以下组件组成： 后端，使用 SQLite 来做数据存储并暴露一个 REST/JSON API； iOS 与 Android 移动客户端，使用 OpenGL； 一个基于 WebAssembly 的浏览器前端用于查看游戏分数。 KotlinConf 应用是一个具有基于 UIKit 的 UI 的 iOS 应用程序，展示了 Kotlin/Native 与 Objective-C 互操作的便利性。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"Native","slug":"Native","permalink":"http://oushiun.com/tags/Native/"}]},{"title":"使用 Kotlin 进行 JavaScript 开发","slug":"kotlin-js-overview","date":"2018-05-15T02:47:22.000Z","updated":"2018-05-15T03:17:36.723Z","comments":true,"path":"2018/05/15/kotlin-js-overview/","link":"","permalink":"http://oushiun.com/2018/05/15/kotlin-js-overview/","excerpt":"Kotlin 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现。目前的实现目标是 ECMAScript 5.1，但也有最终目标为 ECMAScript 2015 的计划。 当你选择 JavaScript 目标时，作为项目一部分的任何 Kotlin 代码以及 Kotlin 附带的标准库都会转换为 JavaScript。然而，这不包括使用的 JDK 和任何 JVM 或 Java 框架或库。任何不是 Kotlin 的文件会在编译期间忽略掉。 Kotlin 编译器努力遵循以下目标： 提供最佳大小的输出 提供可读的 JavaScript 输出 提供与现有模块系统的互操作性 在标准库中提供相同的功能，无论是 JavaScript 还是 JVM 目标（尽最大可能程度）。","text":"Kotlin 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现。目前的实现目标是 ECMAScript 5.1，但也有最终目标为 ECMAScript 2015 的计划。 当你选择 JavaScript 目标时，作为项目一部分的任何 Kotlin 代码以及 Kotlin 附带的标准库都会转换为 JavaScript。然而，这不包括使用的 JDK 和任何 JVM 或 Java 框架或库。任何不是 Kotlin 的文件会在编译期间忽略掉。 Kotlin 编译器努力遵循以下目标： 提供最佳大小的输出 提供可读的 JavaScript 输出 提供与现有模块系统的互操作性 在标准库中提供相同的功能，无论是 JavaScript 还是 JVM 目标（尽最大可能程度）。 如何使用你可能希望在以下情景中将 Kotlin 编译为 JavaScript： 创建面向客户端 JavaScript 的 Kotlin 代码 与 DOM 元素交互。Kotlin 提供了一系列静态类型的接口来与文档对象模型（Document Object Model）交互，允许创建和更新 DOM 元素。 与图形如 WebGL 交互。你可以使用 Kotlin 在网页上用 WebGL 创建图形元素。 创建面向服务器端 JavaScript 的 Kotlin 代码 使用服务器端技术。你可以使用 Kotlin 与服务器端 JavaScript（如 Node.js）进行交互 Kotlin 可以与现有的第三方库和框架（如 jQuery 或 ReactJS）一起使用。要使用强类型API 访问第三方框架，可以使用 ts2kt 工具将 TypeScript 定义从 Definitely Typed类型定义仓库转换为 Kotlin。或者，你可以使用动态类型访问任何框架，而无需强类型。 JetBrains 特地为 React 社区开发并维护了几个工具：React bindings 以及 Create React Kotlin App。后者可以帮你开始使用 Kotlin 构建 React 应用程序而无需构建配置。 Kotlin 兼容 CommonJS、AMD 和 UMD，直截了当与不同的模块系统交互。 Kotlin 转 JavaScript 入门要了解如何开始使用 JavaScript 平台的 Kotlin，请参考其教程。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://oushiun.com/tags/JavaScript/"}]},{"title":"使用 Kotlin 进行 Android 开发","slug":"kotlin-android-overview","date":"2018-05-15T02:31:26.000Z","updated":"2018-05-15T03:17:18.859Z","comments":true,"path":"2018/05/15/kotlin-android-overview/","link":"","permalink":"http://oushiun.com/2018/05/15/kotlin-android-overview/","excerpt":"Kotlin 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制： 兼容性：Kotlin 与 JDK 6 完全兼容，保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统。 性能：由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。 互操作性：Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库。这包括注解处理，所以数据绑定和 Dagger 也是一样。 占用：Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。在实际应用程序中，Kotlin 运行时只增加几百个方法以及 .apk 文件不到 100K 大小。 编译时长：Kotlin 支持高效的增量编译，所以对于清理构建会有额外的开销，增量构建通常与 Java 一样快或者更快。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换有助于迈出第一步。","text":"Kotlin 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制： 兼容性：Kotlin 与 JDK 6 完全兼容，保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统。 性能：由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。 互操作性：Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库。这包括注解处理，所以数据绑定和 Dagger 也是一样。 占用：Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。在实际应用程序中，Kotlin 运行时只增加几百个方法以及 .apk 文件不到 100K 大小。 编译时长：Kotlin 支持高效的增量编译，所以对于清理构建会有额外的开销，增量构建通常与 Java 一样快或者更快。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换有助于迈出第一步。 Kotlin 用于 Android 的案例学习Kotlin 已被一些大公司成功采用，其中一些公司分享了他们的经验： Pinterest 已经成功地将 Kotlin 引入了他们的应用程序中，每个月有 1 亿 5 千万人使用。 Basecamp 的 Android 应用程序是 100％ Kotlin 代码，他们报告了程序员幸福的巨大差异，以及工作质量和速度的巨大改善。 Keepsafe 的 App Lock 应用程序也已转换为 100％ Kotlin，使源代码行数减少 30％、方法数减少 10％。 用于 Android 开发的工具Kotlin 团队为 Android 开发提供了一套超越标准语言功能的工具： Kotlin Android 扩展是一个编译器扩展，可以让你摆脱代码中的 findViewById() 调用，并将其替换为合成的编译器生成的属性。 Anko 是一个提供围绕 Android API 的 Kotlin 友好的包装器的库，以及一个可以用 Kotlin 代码替换布局 .xml 文件的 DSL。 下一步 下载并安装 Android Studio 3.0，其中包含开箱即用的 Kotlin 支持。 按照 Android 与 Kotlin 入门教程创建你的第一个 Kotlin 应用程序。 关于更深入的介绍，请查看本站的参考文档。 另一个很好的资源是 Kotlin for Android Developers，这本书会引导你逐步完成在 Kotlin 中创建真正的 Android 应用程序的过程。 检出 Google 的 Kotlin 写的示例项目。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"Android","slug":"Android","permalink":"http://oushiun.com/tags/Android/"}]},{"title":"使用 Kotlin 进行服务器端开发","slug":"kotlin-server-overview","date":"2018-05-15T01:22:38.000Z","updated":"2018-05-15T03:17:28.884Z","comments":true,"path":"2018/05/15/kotlin-server-overview/","link":"","permalink":"http://oushiun.com/2018/05/15/kotlin-server-overview/","excerpt":"Kotlin 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码，同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线： 表现力：Kotlin 的革新式语言功能，例如支持类型安全的构建器和委托属性，有助于构建强大而易于使用的抽象。 可伸缩性：Kotlin 对协程的支持有助于构建服务器端应用程序，伸缩到适度的硬件要求以应对大量的客户端。 互操作性：Kotlin 与所有基于 Java 的框架完全兼容，可以让你保持熟悉的技术栈，同时获得更现代化语言的优势。 迁移：Kotlin 支持大型代码库从 Java 到 Kotlin 逐步迁移。你可以开始用 Kotlin 编写新代码，同时系统中较旧部分继续用 Java。 工具：除了很棒的 IDE 支持之外，Kotlin 还为 IntelliJ IDEA Ultimate 的插件提供了框架特定的工具（例如Spring）。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换器有助于迈出第一步。","text":"Kotlin 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码，同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线： 表现力：Kotlin 的革新式语言功能，例如支持类型安全的构建器和委托属性，有助于构建强大而易于使用的抽象。 可伸缩性：Kotlin 对协程的支持有助于构建服务器端应用程序，伸缩到适度的硬件要求以应对大量的客户端。 互操作性：Kotlin 与所有基于 Java 的框架完全兼容，可以让你保持熟悉的技术栈，同时获得更现代化语言的优势。 迁移：Kotlin 支持大型代码库从 Java 到 Kotlin 逐步迁移。你可以开始用 Kotlin 编写新代码，同时系统中较旧部分继续用 Java。 工具：除了很棒的 IDE 支持之外，Kotlin 还为 IntelliJ IDEA Ultimate 的插件提供了框架特定的工具（例如Spring）。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换器有助于迈出第一步。 使用 Kotlin 进行服务器端开发的框架 Spring 利用 Kotlin 的语言功能提供更简洁的 API，从版本 5.0 开始。在线项目生成器允许用 Kotlin 快速生成一个新项目。 Vert.x 是在 JVM 上构建响应式 Web 应用程序的框架，为 Kotlin 提供了专门支持，包括完整的文档。 Ktor 是由 JetBrains 构建的 Kotlin 原生 Web 框架，利用协程实现高可伸缩性，并提供易于使用且合乎惯用法的 API。 kotlinx.html 是可在 Web 应用程序中用于构建 HTML 的 DSL。它可以作为传统模板系统（如JSP和FreeMarker）的替代品。 通过相应 Java 驱动程序进行持久化的可用选项包括直接 JDBC 访问、JPA 以及使用 NoSQL 数据库。对于 JPA，kotlin-jpa 编译器插件使 Kotlin 编译的类适应框架的要求。 部署 Kotlin 服务器端应用程序Kotlin 应用程序可以部署到支持 Java Web 应用程序的任何主机，包括 Amazon Web Services、Google Cloud Platform 等。 要在 Heroku 上部署 Kotlin 应用程序，可以按照 Heroku 官方教程来做。 AWS Labs 提供了一个示例项目，展示了 Kotlin 编写 AWS Lambda 函数的使用。 Kotlin 用于服务器端的用户Corda 是一个开源的分布式分类帐平台，由各大银行提供支持，完全由 Kotlin 构建。 JetBrains 账户，负责 JetBrains 整个许可证销售和验证过程的系统 100％ 由 Kotlin 编写，自 2015 年生产运行以来，一直没有重大问题。 下一步 使用 Http Servlet 创建 Web 应用程序 及 使用 Spring Boot 创建 RESTful Web 服务教程将向你展示如何在 Kotlin 中构建和运行非常小的 Web 应用程序。 关于更深入的介绍，请查看本站的参考文档 及 Kotlin 心印。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"服务器端","slug":"服务器端","permalink":"http://oushiun.com/tags/服务器端/"}]},{"title":"ContOS 7 安装 BBR","slug":"centos-install-bbr","date":"2018-05-12T11:02:51.000Z","updated":"2018-05-15T03:05:20.120Z","comments":true,"path":"2018/05/12/centos-install-bbr/","link":"","permalink":"http://oushiun.com/2018/05/12/centos-install-bbr/","excerpt":"Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。","text":"Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。 CentOS 7.3 yum系统更新（更新到CentOS 7.3） 1yum update 查看系统版本 1cat /etc/redhat-release 输出如下（release数值大于7.3即可），则表示已升级到7.3 1CentOS Linux release 7.3.1611 (Core) 安装elrepo并升级内核 123rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install kernel-ml -y 正常情况下将输出如下信息： 1234567891011121314151617Transaction Summary================================================================================Install 1 PackageTotal download size: 39 MInstalled size: 169 MDownloading packages:kernel-ml-4.9.0-1.el7.elrepo.x86_64.rpm | 39 MB 00:00Running transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum. Installing : kernel-ml-4.9.0-1.el7.elrepo.x86_64 1/1 Verifying : kernel-ml-4.9.0-1.el7.elrepo.x86_64 1/1Installed: kernel-ml.x86_64 0:4.9.0-1.el7.elrepoComplete! 更新grub文件并重启（reboot后，ssh会断开，稍等一会儿重新连接） 123egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\'grub2-set-default 0reboot 开机后查看内核是否已更换为4.9 1uname -r 输出如下内容则表示内核4.9已经启动了（数值大于4.9即可） 14.9.0-1.el7.elrepo.x86_64 CentOS 7.4导入 elrepo 软件源的 GPG 公钥 1rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 导入 elrepo 软件源 说明：该地址可以自动下载该源的最新的软件列表，无需修改地址。 1rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 下载并安装新的内核 启用软件源并下载安装最新稳定版内核 1yum -y --enablerepo=elrepo-kernel install kernel-ml 设定 Grub 默认启动新内核 说明：如果手动修改过 Grub 的配置文件，以下命令可能无法执行成功。请自行修改 Grub 配置文件。 1grub2-set-default 0 使用新的内核重启 1reboot 检查设置 &amp; 删除旧的内核 查看当前系统的内核版本号 1uname -r 如果输出是 4.10 以上的版本，说明安装成功。 14.14.13-1.el7.elrepo.x86_64 删除旧内核 说明：删除旧内核的目的是为了防止 yum 更新旧版内核之后覆盖了 grub 默认启动项 1yum -y remove kernel kernel-tools 开启BBR1vim /etc/sysctl.conf 添加如下内容 12net.core.default_qdisc = fqnet.ipv4.tcp_congestion_control = bbr 加载系统参数（正常情况下会输出我们之前加入的内容） 1sysctl -p 验证bbr是否已经开启 a.若 1sysctl net.ipv4.tcp_available_congestion_control 返回 1net.ipv4.tcp_available_congestion_control = bbr cubic reno 则成功 b.若 1lsmod | grep bbr 返回形如如下形式的信息即成功。 12tcp_bbr 16384 1tcp_bbr 20480 0","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"BBR","slug":"BBR","permalink":"http://oushiun.com/tags/BBR/"},{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"}]},{"title":"Css 盒子模型","slug":"css-box-model","date":"2018-05-10T14:46:15.000Z","updated":"2018-05-15T03:05:40.216Z","comments":true,"path":"2018/05/10/css-box-model/","link":"","permalink":"http://oushiun.com/2018/05/10/css-box-model/","excerpt":"盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。需要记住的是：”every element in web design is a rectangular box”。如图：","text":"盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。需要记住的是：”every element in web design is a rectangular box”。如图： CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) margin叠加外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。 一般来说， 垂直外边距叠加有三种情况： 元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。 相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。 包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。 参考资料CSS-TRICKS:The CSS Box Model CSS Magic: The Box","categories":[{"name":"前端","slug":"前端","permalink":"http://oushiun.com/categories/前端/"},{"name":"Css","slug":"前端/Css","permalink":"http://oushiun.com/categories/前端/Css/"}],"tags":[{"name":"Box Model","slug":"Box-Model","permalink":"http://oushiun.com/tags/Box-Model/"}]},{"title":"CentOS 搭建 shadowsocks","slug":"centos-install-shadowsocks","date":"2018-05-09T14:20:38.000Z","updated":"2018-05-15T03:05:34.786Z","comments":true,"path":"2018/05/09/centos-install-shadowsocks/","link":"","permalink":"http://oushiun.com/2018/05/09/centos-install-shadowsocks/","excerpt":"Shadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。","text":"Shadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。 安装shadowsocks安装pipPip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。 123wget https://bootstrap.pypa.io/get-pip.pypython get-pip.pypip -V #pip 10.0.1 from /usr/lib/python2.7/site-packages/pip (python 2.7) 通过pip安装shadowsocks12pip install --upgrade pippip install shadowsocks 配置shadowsocks1234567891011# vi /etc/shadowsocks.json&#123; \"server\":\"x.x.x.x\", #你的 ss 服务器 ip \"server_port\":0, #你的 ss 服务器端口 \"local_address\": \"127.0.0.1\", #本地ip \"local_port\":0, #本地端口 \"password\":\"password\", #连接 ss 密码 \"timeout\":300, #等待超时 \"method\":\"aes-256-cfb\", #加密方式 \"workers\": 1 #工作线程数&#125; systemctl设置1234567891011121314# vi /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid --log-file /var/log/shadowsocks.log -c /etc/shadowsocks.json -d startRestart=on-abort[Install]WantedBy=multi-user.target 配置firwall规则输入以下命令开启一个端口，如果不是 9002 端口，修改成自己需要添加的端口（–permanent 永久生效，没有此参数重启后失效）。 1firewall-cmd --zone=public --add-port=9002/tcp --permanent 添加端口后系统返回success说明添加成功。这个时候需要重新载入 firewall，输入以下命令，返回success后此端口就可使用 1firewall-cmd --reload shadowsocks其他配置1234567891011121314151617181920212223242526272829ssserver -husage: ssserver [OPTION]...A fast tunnel proxy that helps you bypass firewalls.You can supply configurations via either config file or command line arguments.Proxy options: -c CONFIG path to config file -s SERVER_ADDR server address, default: 0.0.0.0 -p SERVER_PORT server port, default: 8388 -k PASSWORD password -m METHOD encryption method, default: aes-256-cfb -t TIMEOUT timeout in seconds, default: 300 --fast-open use TCP_FASTOPEN, requires Linux 3.7+ --workers WORKERS number of workers, available on Unix/Linux --forbidden-ip IPLIST comma seperated IP list forbidden to connect --manager-address ADDR optional server manager UDP address, see wikiGeneral options: -h, --help show this help message and exit -d start/stop/restart daemon mode --pid-file PID_FILE pid file for daemon mode --log-file LOG_FILE log file for daemon mode --user USER username to run as -v, -vv verbose mode -q, -qq quiet mode, only show warnings/errors --version show version informationOnline help: &lt;https://github.com/shadowsocks/shadowsocks&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://oushiun.com/tags/shadowsocks/"}]},{"title":"Markdown","slug":"markdown","date":"2018-05-09T01:41:47.000Z","updated":"2018-05-15T02:55:14.825Z","comments":true,"path":"2018/05/09/markdown/","link":"","permalink":"http://oushiun.com/2018/05/09/markdown/","excerpt":"A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF).","text":"A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF). Block ElementsParagraphs and Line BreaksParagraphsHTML Tag: &lt;p&gt; One or more blank lines. (A blank line is a line containing nothing but spaces or tabs is considered blank.) Code: This will be inline. This is second paragraph. Preview: This will beinline. This is second paragraph. Line BreaksHTML Tag: &lt;br /&gt; End a line with two or more spaces. Code: This will be not inline. Preview: This will be notinline. HeadersMarkdown supports two styles of headers, Setext and atx. SetextHTML Tags: &lt;h1&gt;, &lt;h2&gt; “Underlined” using equal signs (=) as &lt;h1&gt; and dashes (-) as &lt;h2&gt; in any number. Code: This is an H1 ============= This is an H2 ------------- Preview: This is an H1This is an H2 atxHTML Tags: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; Uses 1-6 hash characters (#) at the start of the line, corresponding to &lt;h1&gt; - &lt;h6&gt;. Code: # This is an H1 ## This is an H2 ###### This is an H6 Preview: This is an H1This is an H2This is an H6 Optionally, you may “close” atx-style headers. The closing hashes don’t need to match the number of hashes used to open the header. Code: # This is an H1 # ## This is an H2 ## ### This is an H3 ###### Preview: This is an H1This is an H2This is an H3 BlockquotesHTML Tag: &lt;blockquote&gt; Markdown uses email-style &gt; characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;. Code: &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. Preview: This is the first level of quoting. This is nested blockquote. Back to the first level. Blockquotes can contain other Markdown elements, including headers, lists, and code blocks. Code: &gt; ## This is a header. &gt; &gt; 1. This is the first list item. &gt; 2. This is the second list item. &gt; &gt; Here&apos;s some example code: &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); Preview: This is a header. This is the first list item. This is the second list item. Here’s some example code: return shell_exec(&quot;echo $input | $markdown_script&quot;); ListsMarkdown supports ordered (numbered) and unordered (bulleted) lists. UnorderedHTML Tag: &lt;ul&gt; Unordered lists use asterisks (*), pluses (+), and hyphens (-). Code: * Red * Green * Blue Preview: Red Green Blue is equivalent to: Code: + Red + Green + Blue and: Code: - Red - Green - Blue OrderedHTML Tag: &lt;ol&gt; Ordered lists use numbers followed by periods: Code: 1. Bird 2. McHale 3. Parish Preview: Bird McHale Parish It’s possible to trigger an ordered list by accident, by writing something like this: Code: 1986. What a great season. Preview: What a great season. You can backslash-escape (\\) the period: Code: 1986\\. What a great season. Preview: 1986. What a great season. IndentedBlockquoteTo put a blockquote within a list item, the blockquote’s &gt; delimiters need to be indented: Code: * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. Preview: A list item with a blockquote: This is a blockquoteinside a list item. Code BlockTo put a code block within a list item, the code block needs to be indented twice — 8 spaces or two tabs: Code: * A list item with a code block: &lt;code goes here&gt; Preview: A list item with a code block: &lt;code goes here&gt; Nested ListCode: * A * A1 * A2 * B * C Preview: A A1 A2 B C Code BlocksHTML Tag: &lt;pre&gt; Indent every line of the block by at least 4 spaces or 1 tab. Code: This is a normal paragraph: This is a code block. Preview: This is a normal paragraph: This is a code block. A code block continues until it reaches a line that is not indented (or the end of the article). Within a code block, ampersands (&amp;) and angle brackets (&lt; and &gt;) are automatically converted into HTML entities. Code: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Preview: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block. Fenced Code BlocksJust wrap your code in ``` ```` (as shown below) and you won't need to indent it by four spaces.1234Code: Here&apos;s an example: function test() { console.log(&quot;notice the blank line before this function?&quot;); } 123Preview:***Here&apos;s an example: function test() { console.log(“notice the blank line before this function?”);}12345678910***#### Syntax HighlightingIn your fenced block, add an optional language identifier and we&apos;ll run it through syntax highlighting ([Support Languages](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml)).Code: ```ruby require &apos;redcarpet&apos; markdown = Redcarpet.new(&quot;Hello World!&quot;) puts markdown.to_html Preview: 123require 'redcarpet'markdown = Redcarpet.new(\"Hello World!\")puts markdown.to_html Horizontal RulesHTML Tag: &lt;hr /&gt;Places three or more hyphens (-), asterisks (*), or underscores (_) on a line by themselves. You may use spaces between the hyphens or asterisks. Code: * * * *** ***** - - - --------------------------------------- ___ Preview: TableHTML Tag: &lt;table&gt; It’s an extension. Separates column by pipe (|) and header by dashes (-), and uses colon (:) for alignment. The outer pipes (|) and alignment are optional. There are 3 delimiters each cell at least for separating header. Code:12345678910111213| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff | A | B---|---123|456A |B--|--12|45 Preview: Left Center Right aaa bbb ccc ddd eee fff A B 123 456 A B 12 45 Span ElementsLinksHTML Tag: &lt;a&gt; Markdown supports two style of links: inline and reference. InlineInline link format like this: [Link Text](URL &quot;Title&quot;) Title is optional. Code: This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. Preview: This is an example inline link. This link has no title attribute. If you’re referring to a local resource on the same server, you can use relative paths: Code: See my [About](/about/) page for details. Preview: See my About page for details. ReferenceYou could predefine link references. Format like this: [id]: URL &quot;Title&quot; Title is also optional. And the you refer the link, format like this: [Link Text][id] Code: [id]: http://example.com/ &quot;Optional Title Here&quot; This is [an example][id] reference-style link. Preview: This is an example reference-style link. That is: Square brackets containing the link identifier (not case sensitive, optionally indented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; The link URL may, optionally, be surrounded by angle brackets. optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses. The following three link definitions are equivalent: Code: [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) [foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; Uses an empty set of square brackets, the link text itself is used as the name. Code: [Google]: http://google.com/ [Google][] Preview: Google EmphasisHTML Tags: &lt;em&gt;, &lt;strong&gt; Markdown treats asterisks (*) and underscores (_) as indicators of emphasis. One delimiter will be &lt;em&gt;; *double delimiters will be &lt;strong&gt;. Code: *single asterisks* _single underscores_ **double asterisks** __double underscores__ Preview: single asterisks single underscores double asterisks double underscores But if you surround an * or _ with spaces, it’ll be treated as a literal asterisk or underscore. You can backslash escape it: Code: \\*this text is surrounded by literal asterisks\\* Preview: *this text is surrounded by literal asterisks* CodeHTML Tag: &lt;code&gt; Wraps it with backtick quotes (`). Code: Use the `printf()` function. Preview: Use the printf() function. To include a literal backtick character within a code span, you can use multiple backticks as the opening and closing delimiters: Code: ``There is a literal backtick (`) here.`` Preview: There is a literal backtick (`) here. The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span: Code: A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` Preview: A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` ImagesHTML Tag: &lt;img /&gt; Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference. InlineInline image syntax looks like this: ![Alt text](URL &quot;Title&quot;) Title is optional. Code: ![Alt text](https://static.oushiun.com/blog/img/desk.jpg) ![Alt text](https://static.oushiun.com/blog/img/desk.jpg &quot;Optional title&quot;) Preview: That is: An exclamation mark: !; followed by a set of square brackets, containing the alt attribute text for the image; followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes. ReferenceReference-style image syntax looks like this: ![Alt text][id] Code: [img id]: https://static.oushiun.com/blog/img/desk.jpg &quot;Optional title attribute&quot; ![Alt text][img id] Preview: StrikethroughHTML Tag: &lt;del&gt; It’s an extension. GFM adds syntax to strikethrough text. Code:1~~Mistaken text.~~ Preview: Mistaken text. MiscellaneousAutomatic LinksMarkdown supports a shortcut style for creating “automatic” links for URLs and email addresses: simply surround the URL or email address with angle brackets. Code: &lt;http://example.com/&gt; &lt;address@example.com&gt; Preview: http://example.com/ &#97;&#x64;&#x64;&#x72;&#101;&#115;&#115;&#64;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#109; GFM will autolink standard URLs. Code:1https://github.com/emn178/markdown Preview: https://github.com/emn178/markdown Backslash EscapesMarkdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown’s formatting syntax. Code: \\*literal asterisks\\* Preview: *literal asterisks* Markdown provides backslash escapes for the following characters: Code: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark Inline HTMLFor any markup that is not covered by Markdown’s syntax, you simply use HTML itself. There’s no need to preface it or delimit it to indicate that you’re switching from Markdown to HTML; you just use the tags. Code: This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. Preview: This is a regular paragraph. Foo This is another regular paragraph. Note that Markdown formatting syntax is not processed within block-level HTML tags. Unlike block-level HTML tags, Markdown syntax is processed within span-level tags. Code: &lt;span&gt;**Work**&lt;/span&gt; &lt;div&gt; **No Work** &lt;/div&gt; Preview: Work No Work","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://oushiun.com/tags/Markdown/"}]},{"title":"CentOS 搭建 jetbrains 破解服务器","slug":"centos-install-jetbrains-server","date":"2018-05-08T09:18:37.000Z","updated":"2018-05-15T03:05:30.929Z","comments":true,"path":"2018/05/08/centos-install-jetbrains-server/","link":"","permalink":"http://oushiun.com/2018/05/08/centos-install-jetbrains-server/","excerpt":"CentOS 搭建 jetbrains 破解服务器","text":"CentOS 搭建 jetbrains 破解服务器 安装步骤 检查是否安装了vsftpd 1rpm -qa |grep vsftpd Linux系统：CentOS 7 x86_64 1cat /etc/os-release 通过yum来安装vsftpd 1yum -y install vsftpd 设置为开机启动 123456systemctl enable vsftpdsystemctl start vsftpd #启动vsftpd命令systemctl stop vsftpd #停止vsftpd命令systemctl status vsftpd #查看vsftpd状态systemctl restart vsftpd #重启vsftpd命令 修改配置文件 1vi /etc/vsftpd/vsftpd.conf 添加用户及额外配置 启用root用户进入 /etc/vsftpd 目录下修改 ::ftpusers:: &amp; ::user_list::将 root 用户注释 # 开放 21 端口 1firewall-cmd --zone=public --add-port=21/tcp --permanent 12345678yum install firewalld #安装firewalld 防火墙systemctl start firewalld.service #开启防火墙systemctl stop firewalld.service #关闭防火墙systemctl enable firewalld.service #开机自动启动systemctl disable firewalld.service #禁止开机制动启动firewall-cmd --state #running 表示运行firewall-cmd --reload #重新载入以生效firewall-cmd --complete-reload #更新规则，重启服务 上传文件下载IntelliJ IDEA License Server v1.6(当前使用是v1.6，新版本还请及时关注lanyus) 解压到 某个目录下(任意即可), IntelliJIDEALicenseServer 目录下涵盖了很多平台(mac linux windows)。当前服务器是x86_64 GNU/Linux，so 给IntelliJIDEALicenseServer_linux_amd64 赋可执行权限1chmod +x IntelliJIDEALicenseServer_linux_amd64 安装配置Nginx 通过yum安装Nginx 12yum install epel-releaseyum install nginx 常用命令123systemctl start nginxsystemctl enable nginxsystemctl status nginx 配置防火墙 123firewall-cmd --zone=public --permanent --add-service=httpfirewall-cmd --zone=public --permanent --add-service=httpsfirewall-cmd --reload 测试Nginx是否正常访问http://SERVER_DOMAIN_NAME_OR_IP 修改Nginx配置文件 1234567891011121314151617#vi /usr/local/nginx/conf/nginx.confserver &#123; listen 80; server_name idea.oushiun.com; root /usr/local/nginx/html; location / &#123; proxy_pass http://127.0.0.1:1027; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; access_log /dev/null; error_log /dev/null;&#125; 注意事项：需要展示破解地址文档，通过nginx反向代理需要将IntelliJIDEALicenseServer.html 放在/目录，如果是通过直接运行脚本需要和脚本在同一目录。 systemd 设置 12345678910111213141516# vim /etc/systemd/system/intellij.service[Unit]Description= IntelliJIDEALicenseServe ServiceAfter=network.target[Service]ExecStart=/root/jetbrains/IntelliJIDEALicenseServer_linux_amd64PrivateTmp=true[Install]WantedBy=default.target# systemctl daemon-reload # 重载# systemctl start intellij # 启动# systemctl enable intellij # 开机启动# systemctl disable intellij # 撤销开机启动 IntelliJIDEALicenseServer 帮助 123456789./IntelliJIDEALicenseServer_linux_amd64 -h-l string 绑定的host，基本默认 bind on host (default \"0.0.0.0\") -p int 监听端口，建议改下 port (default 1027) -prolongationPeriod string 过期时间 prolongationPeriod (default \"607875500\") -u string 当未设置-u参数，且计算机用户名为^[a-zA-Z0-9]+$时，使用计算机用户名作为idea用户名 username (default \"ilanyu\")","categories":[{"name":"软件","slug":"软件","permalink":"http://oushiun.com/categories/软件/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"},{"name":"jetbrains","slug":"jetbrains","permalink":"http://oushiun.com/tags/jetbrains/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2018-05-08T02:32:25.448Z","updated":"2018-05-15T02:26:36.556Z","comments":true,"path":"2018/05/08/hello-hexo/","link":"","permalink":"http://oushiun.com/2018/05/08/hello-hexo/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://oushiun.com/categories/其他/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://oushiun.com/tags/Hexo/"}]}]}