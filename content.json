{"meta":{"title":"oushiun","subtitle":null,"description":"互联网产品、技术、设计文章分享","author":"oushiun","url":"http://oushiun.com"},"pages":[{"title":"About","date":"2018-05-15T02:26:48.272Z","updated":"2018-05-15T02:26:48.272Z","comments":false,"path":"about/index.html","permalink":"http://oushiun.com/about/index.html","excerpt":"","text":"玩物丧志 其志小志大者 玩物养志"},{"title":"Tags","date":"2018-05-09T03:07:48.749Z","updated":"2018-05-09T03:07:48.749Z","comments":false,"path":"tags/index.html","permalink":"http://oushiun.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-09T03:07:44.547Z","updated":"2018-05-09T03:07:44.547Z","comments":false,"path":"categories/index.html","permalink":"http://oushiun.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"委托属性","slug":"kotlin/reference/delegated-properties","date":"2018-05-17T06:48:41.000Z","updated":"2018-05-17T06:48:42.226Z","comments":true,"path":"kotlin/reference/delegated-properties.html","link":"","permalink":"http://oushiun.com/kotlin/reference/delegated-properties.html","excerpt":"有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们，但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括： 延迟属性（lazy properties）: 其值只在首次访问时计算； 可观察属性（observable properties）: 监听器会收到有关此属性变更的通知； 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。","text":"有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们，但是如果能够为大家把他们只实现一次并放入一个库会更好。例如包括： 延迟属性（lazy properties）: 其值只在首次访问时计算； 可观察属性（observable properties）: 监听器会收到有关此属性变更的通知； 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。 为了涵盖这些（以及其他）情况，Kotlin 支持 委托属性: 123class Example &#123; var p: String by Delegate()&#125; 语法是： val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 _委托_，因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。例如: 123456789class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return \"$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!\" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(\"$value has been assigned to '$&#123;property.name&#125;' in $thisRef.\") &#125;&#125; 当我们从委托到一个 Delegate 实例的 p 读取时，将调用 Delegate 中的 getValue() 函数，所以它第一个参数是读出 p 的对象、第二个参数保存了对 p 自身的描述（例如你可以取它的名字)。 例如: 12val e = Example()println(e.p) 输出结果： 1Example@33a17727, thank you for delegating ‘p’ to me! 类似地，当我们给 p 赋值时，将调用 setValue() 函数。前两个参数相同，第三个参数保存将要被赋予的值： 1e.p = \"NEW\" 输出结果： 1NEW has been assigned to ‘p’ in Example@33a17727. 委托对象的要求规范可以在下文找到。 请注意，自 Kotlin 1.1 起你可以在函数或代码块中声明一个委托属性，因此它不一定是类的成员。你可以在下文找到其示例。 标准委托Kotlin 标准库为几种有用的委托提供了工厂方法。 延迟属性 Lazylazy() 是接受一个 lambda 并返回一个 Lazy &lt;T&gt; 实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果，后续调用 get() 只是返回记录的结果。 123456789val lazyValue: String by lazy &#123; println(\"computed!\") \"Hello\"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) println(lazyValue)&#125; 这个例子输出： 123computed!HelloHello 默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。而如果你确定初始化将总是发生在单个线程，那么你可以使用 LazyThreadSafetyMode.NONE 模式，它不会有任何线程安全的保证和相关的开销。 可观察属性 ObservableDelegates.observable() 接受两个参数：初始值和修改时处理程序（handler）。每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值和新值： 1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable(\"&lt;no name&gt;\") &#123; prop, old, new -&gt; println(\"$old -&gt; $new\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = \"first\" user.name = \"second\"&#125; 这个例子输出： 12&lt;no name&gt; -&gt; firstfirst -&gt; second 如果你想能够截获一个赋值并“否决”它，就使用 vetoable() 取代 observable()。在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。 把属性储存在映射中一个常见的用例是在一个映射（map）里存储属性的值。这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。 1234class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125; 在这个例子中，构造函数接受一个映射参数： 1234val user = User(mapOf( \"name\" to \"John Doe\", \"age\" to 25)) 委托属性会从这个映射中取值（通过字符串键——属性的名称）： 12println(user.name) // Prints \"John Doe\"println(user.age) // Prints 25 这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话： 1234class MutableUser(val map: MutableMap&lt;String, Any?&gt;) &#123; var name: String by map var age: Int by map&#125; {:#局部委托属性自-11-起} 局部委托属性（自 1.1 起）你可以将局部变量声明为委托属性。例如，你可以使一个局部变量惰性初始化： 1234567fun example(computeFoo: () -&gt; Foo) &#123; val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123; memoizedFoo.doSomething() &#125;&#125; memoizedFoo 变量只会在第一次访问时计算。如果 someCondition 失败，那么该变量根本不会计算。 属性委托要求这里我们总结了委托对象的要求。 对于一个只读属性（即 val 声明的），委托必须提供一个名为 getValue 的函数，该函数接受以下参数： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型； property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 这个函数必须返回与属性相同的类型（或其子类型）。 对于一个可变属性（即 var 声明的），委托必须额外提供一个名为 setValue 的函数，该函数接受以下参数： thisRef —— 同 getValue()； property —— 同 getValue()； new value —— 必须和属性同类型或者是它的超类型。 getValue() 或/和 setValue() 函数可以通过委托类的成员函数提供或者由扩展函数提供。当你需要委托属性到原本未提供的这些函数的对象时后者会更便利。两函数都需要用 operator 关键字来进行标记。 委托类可以实现包含所需 operator 方法的 ReadOnlyProperty 或 ReadWriteProperty 接口之一。这俩接口是在 Kotlin 标准库中声明的： 12345678interface ReadOnlyProperty&lt;in R, out T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T&#125;interface ReadWriteProperty&lt;in R, T&gt; &#123; operator fun getValue(thisRef: R, property: KProperty&lt;*&gt;): T operator fun setValue(thisRef: R, property: KProperty&lt;*&gt;, value: T)&#125; 翻译规则在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性： 1234567891011class C &#123; var prop: Type by MyDelegate()&#125;// 这段是由编译器生成的相应代码：class C &#123; private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。 请注意，直接在代码中引用绑定的可调用引用的语法 this::prop 自 Kotlin 1.1 起才可用。 {:#提供委托自-11-起} 提供委托（自 1.1 起）通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来创建属性委托实例。 provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。 例如，如果要在绑定之前检查属性名称，可以这样写： 1234567891011121314151617181920212223class ResourceDelegate&lt;T&gt; : ReadOnlyProperty&lt;MyUI, T&gt; &#123; override fun getValue(thisRef: MyUI, property: KProperty&lt;*&gt;): T &#123; ... &#125;&#125;class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate( thisRef: MyUI, prop: KProperty&lt;*&gt; ): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, prop.name) // 创建委托 return ResourceDelegate() &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;class MyUI &#123; fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 的参数与 getValue 相同： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型； property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。 如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能，你必须显式传递属性名，这不是很方便： 12345678910111213// 检查属性名称而不使用“provideDelegate”功能class MyUI &#123; val image by bindResource(ResourceID.image_id, \"image\") val text by bindResource(ResourceID.text_id, \"text\")&#125;fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(this, propertyName) // 创建委托&#125; 在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与上面（当 provideDelegate 方法不存在时）生成的代码： 12345678910111213class C &#123; var prop: Type by MyDelegate()&#125;// 这段代码是当“provideDelegate”功能可用时// 由编译器生成的代码：class C &#123; // 调用“provideDelegate”来创建额外的“delegate”属性 private val prop$delegate = MyDelegate().provideDelegate(this, this::prop) var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; 请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"委托","slug":"kotlin/reference/delegation","date":"2018-05-17T03:44:45.000Z","updated":"2018-05-17T06:39:40.992Z","comments":true,"path":"kotlin/reference/delegation.html","link":"","permalink":"http://oushiun.com/kotlin/reference/delegation.html","excerpt":"属性委托属性委托在单独一页中讲：属性委托。 由委托实现委托模式已经证明是实现继承的一个很好的替代方式，而 Kotlin 可以零样板代码地原生支持它。","text":"属性委托属性委托在单独一页中讲：属性委托。 由委托实现委托模式已经证明是实现继承的一个很好的替代方式，而 Kotlin 可以零样板代码地原生支持它。 Derived 类可以通过将其所有公有成员都委托给指定对象来实现一个接口 Base： 1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print()&#125; Derived 的超类型列表中的 by-子句表示 b 将会在 Derived 中内部存储，并且编译器将生成转发给 b 的所有 Base 的方法。 覆盖由委托实现的接口成员覆盖符合预期：编译器会使用 override覆盖的实现而不是委托对象中的。如果将 override fun print() { print(&quot;abc&quot;) } 添加到Derived，那么当调用 print 时程序会输出“abc”而不是“10”： 12345678910111213141516171819interface Base &#123; fun printMessage() fun printMessageLine()&#125;class BaseImpl(val x: Int) : Base &#123; override fun printMessage() &#123; print(x) &#125; override fun printMessageLine() &#123; println(x) &#125;&#125;class Derived(b: Base) : Base by b &#123; override fun printMessage() &#123; print(\"abc\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).printMessage() Derived(b).printMessageLine()&#125; 但请注意，以这种方式重写的成员不会在委托对象的成员中调用，委托对象的成员只能访问其自身对接口成员实现： 123456789101112131415161718192021interface Base &#123; val message: String fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override val message = \"BaseImpl: x = $x\" override fun print() &#123; println(message) &#125;&#125;class Derived(b: Base) : Base by b &#123; // 在 b 的 `print` 实现中不会访问到这个属性 override val message = \"Message of Derived\"&#125;fun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) val derived = Derived(b) derived.print() println(derived.message)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"嵌套类与内部类","slug":"kotlin/reference/nested-classes","date":"2018-05-17T03:38:12.000Z","updated":"2018-05-17T03:44:25.941Z","comments":true,"path":"kotlin/reference/nested-classes.html","link":"","permalink":"http://oushiun.com/kotlin/reference/nested-classes.html","excerpt":"类可以嵌套在其他类中： 12345678class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125;val demo = Outer.Nested().foo() // == 2","text":"类可以嵌套在其他类中： 12345678class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125;val demo = Outer.Nested().foo() // == 2 内部类类可以标记为 inner 以便能够访问外部类的成员。内部类会带有一个对外部类的对象的引用： 12345678class Outer &#123; private val bar: Int = 1 inner class Inner &#123; fun foo() = bar &#125;&#125;val demo = Outer().Inner().foo() // == 1 参见限定的 this 表达式以了解内部类中的 this 的消歧义用法。 匿名内部类使用对象表达式创建匿名内部类实例： 123456789window.addMouseListener(object: MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125;) 如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例，你可以使用带接口类型前缀的 lambda 表达式创建它： 1val listener = ActionListener &#123; println(\"clicked\") &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"对象表达式与对象声明","slug":"kotlin/reference/object-declarations","date":"2018-05-17T03:38:12.000Z","updated":"2018-05-17T03:44:27.404Z","comments":true,"path":"kotlin/reference/object-declarations.html","link":"","permalink":"http://oushiun.com/kotlin/reference/object-declarations.html","excerpt":"有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。Java 用匿名内部类 处理这种情况。Kotlin 用对象表达式和对象声明对这个概念稍微概括了下。","text":"有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。Java 用匿名内部类 处理这种情况。Kotlin 用对象表达式和对象声明对这个概念稍微概括了下。 对象表达式要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写： 123456789window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125;) 如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。多个超类型可以由跟在冒号后面的逗号分隔的列表指定： 123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;……&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写： 1234567fun foo() &#123; val adHoc = object &#123; var x: Int = 0 var y: Int = 0 &#125; print(adHoc.x + adHoc.y)&#125; 请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。 12345678910111213141516class C &#123; // 私有函数，所以其返回类型是匿名对象类型 private fun foo() = object &#123; val x: String = \"x\" &#125; // 公有函数，所以其返回类型是 Any fun publicFoo() = object &#123; val x: String = \"x\" &#125; fun bar() &#123; val x1 = foo().x // 没问题 val x2 = publicFoo().x // 错误：未能解析的引用“x” &#125;&#125; 就像 Java 匿名内部类一样，对象表达式中的代码可以访问来自包含它的作用域的变量。（与 Java 不同的是，这不仅限于 final 变量。） 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ……&#125; 对象声明单例模式在一些场景中很有用，而 Kotlin（继 Scala 之后）使单例声明变得很容易： 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // …… &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ……&#125; 这称为对象声明。并且它总是在 object 关键字后跟一个名称。就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。 对象声明的初始化过程是线程安全的。 如需引用该对象，我们直接使用其名称即可： 1DataProviderManager.registerDataProvider(……) 这些对象可以有超类型： 123456789object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125; 注意：对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。 伴生对象类内部的对象声明可以用 companion 关键字标记： 12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125; 该伴生对象的成员可通过只使用类名作为限定符来调用： 1val instance = MyClass.create() 可以省略伴生对象的名称，在这种情况下将使用名称 Companion： 123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口： 12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节。 对象表达式和对象声明之间的语义差异对象表达式和对象声明之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行（及初始化）的； 对象声明是在第一次被访问到时延迟初始化的； 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"枚举类","slug":"kotlin/reference/enum-classes","date":"2018-05-17T03:38:12.000Z","updated":"2018-05-17T03:44:24.337Z","comments":true,"path":"kotlin/reference/enum-classes.html","link":"","permalink":"http://oushiun.com/kotlin/reference/enum-classes.html","excerpt":"枚举类的最基本的用法是实现类型安全的枚举： 123enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125; 每个枚举常量都是一个对象。枚举常量用逗号分隔。","text":"枚举类的最基本的用法是实现类型安全的枚举： 123enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125; 每个枚举常量都是一个对象。枚举常量用逗号分隔。 初始化因为每一个枚举都是枚举类的实例，所以他们可以是这样初始化过的： 12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 匿名类枚举常量也可以声明自己的匿名类： 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 及相应的方法、以及覆盖基类的方法。注意，如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开，就像在 Java 中一样。 枚举条目不能包含内部类以外的嵌套类型（已在 Kotlin 1.2 中弃用）。 使用枚举常量就像在 Java 中一样，Kotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）： 12EnumClass.valueOf(value: String): EnumClassEnumClass.values(): Array&lt;EnumClass&gt; 如果指定的名称与类中定义的任何枚举常量均不匹配，valueOf() 方法将抛出 IllegalArgumentException 异常。 自 Kotlin 1.1 起，可以使用 enumValues&lt;T&gt;() 和 enumValueOf&lt;T&gt;() 函数以泛型的方式访问枚举类中的常量： 1234567enum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE 每个枚举常量都具有在枚举类声明中获取其名称和位置的属性： 12val name: Stringval ordinal: Int 枚举常量还实现了 Comparable 接口，其中自然顺序是它们在枚举类中定义的顺序。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"泛型","slug":"kotlin/reference/generics","date":"2018-05-17T03:33:54.000Z","updated":"2018-05-17T03:33:55.618Z","comments":true,"path":"kotlin/reference/generics.html","link":"","permalink":"http://oushiun.com/kotlin/reference/generics.html","excerpt":"与 Java 类似，Kotlin 中的类也可以有类型参数： 123class Box&lt;T&gt;(t: T) &#123; var value = t&#125;","text":"与 Java 类似，Kotlin 中的类也可以有类型参数： 123class Box&lt;T&gt;(t: T) &#123; var value = t&#125; 一般来说，要创建这样类的实例，我们需要提供类型参数： 1val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1) 但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数： 1val box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。 型变Java 类型系统中最棘手的部分之一是通配符类型（参见 Java Generics FAQ）。而 Kotlin 中没有。 相反，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。 首先，让我们思考为什么 Java 需要那些神秘的通配符。在 《Effective Java》第三版 解释了该问题——第 31 条：利用有限制通配符来提升 API 的灵活性。首先，Java 中的泛型是不型变的，这意味着 List&lt;String&gt; 并不是 List&lt;Object&gt; 的子类型。为什么这样？ 如果 List 不是不型变的，它就没比 Java 的数组好到哪去，因为如下代码会通过编译然后导致运行时异常： 12345// JavaList&lt;String&gt; strs = new ArrayList&lt;String&gt;();List&lt;Object&gt; objs = strs; // ！！！即将来临的问题的原因就在这里。Java 禁止这样！objs.add(1); // 这里我们把一个整数放入一个字符串列表String s = strs.get(0); // ！！！ ClassCastException：无法将整数转换为字符串 因此，Java 禁止这样的事情以保证运行时的安全。但这样会有一些影响。例如，考虑 Collection 接口中的 addAll()方法。该方法的签名应该是什么？直觉上，我们会这样： 1234// Javainterface Collection&lt;E&gt; …… &#123; void addAll(Collection&lt;E&gt; items);&#125; 但随后，我们将无法做到以下简单的事情（这是完全安全）： 12345// Javavoid copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from) &#123; to.addAll(from); // ！！！对于这种简单声明的 addAll 将不能编译： // Collection&lt;String&gt; 不是 Collection&lt;Object&gt; 的子类型&#125; （在 Java 中，我们艰难地学到了这个教训，参见《Effective Java》第三版，第 28 条：列表优先于数组） 这就是为什么 addAll() 的实际签名是以下这样： 1234// Javainterface Collection&lt;E&gt; …… &#123; void addAll(Collection&lt;? extends E&gt; items);&#125; 通配符类型参数 ? extends E 表示此方法接受 E 或者 E 的 一些子类型对象的集合，而不只是 E 自身。这意味着我们可以安全地从其中（该集合中的元素是 E 的子类的实例）读取 E，但不能写入，因为我们不知道什么对象符合那个未知的 E 的子类型。反过来，该限制可以让Collection&lt;String&gt;表示为Collection&lt;? extends Object&gt;的子类型。简而言之，带 extends 限定（上界）的通配符类型使得类型是协变的（covariant）。 理解为什么这个技巧能够工作的关键相当简单：如果只能从集合中获取项目，那么使用 String 的集合，并且从其中读取 Object 也没问题 。反过来，如果只能向集合中 _放入_ 项目，就可以用Object 集合并向其中放入 String：在 Java 中有 List&lt;? super String&gt; 是 List&lt;Object&gt; 的一个超类。 后者称为逆变性（contravariance），并且对于 List &lt;? super String&gt; 你只能调用接受 String 作为参数的方法（例如，你可以调用 add(String) 或者 set(int, String)），当然如果调用函数返回 List&lt;T&gt; 中的 T，你得到的并非一个 String 而是一个 Object。 Joshua Bloch 称那些你只能从中读取的对象为生产者，并称那些你只能写入的对象为消费者。他建议：“为了灵活性最大化，在表示生产者或消费者的输入参数上使用通配符类型”，并提出了以下助记符： PECS 代表生产者-Extens，消费者-Super（Producer-Extends, Consumer-Super）。 注意：如果你使用一个生产者对象，如 List&lt;? extends Foo&gt;，在该对象上不允许调用 add() 或 set()。但这并不意味着该对象是不可变的：例如，没有什么阻止你调用 clear()从列表中删除所有项目，因为 clear()根本无需任何参数。通配符（或其他类型的型变）保证的唯一的事情是类型安全。不可变性完全是另一回事。 声明处型变假设有一个泛型接口 Source&lt;T&gt;，该接口中不存在任何以 T 作为参数的方法，只是方法返回 T 类型值： 1234// Javainterface Source&lt;T&gt; &#123; T nextT();&#125; 那么，在 Source &lt;Object&gt; 类型的变量中存储 Source &lt;String&gt; 实例的引用是极为安全的——没有消费者-方法可以调用。但是 Java 并不知道这一点，并且仍然禁止这样操作： 12345// Javavoid demo(Source&lt;String&gt; strs) &#123; Source&lt;Object&gt; objects = strs; // ！！！在 Java 中不允许 // ……&#125; 为了修正这一点，我们必须声明对象的类型为 Source&lt;? extends Object&gt;，这是毫无意义的，因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。但编译器并不知道。 在 Kotlin 中，有一种方法向编译器解释这种情况。这称为声明处型变：我们可以标注 Source 的类型参数 T 来确保它仅从 Source&lt;T&gt; 成员中返回（生产），并从不被消费。为此，我们提供 out 修饰符： 12345678interface Source&lt;out T&gt; &#123; fun nextT(): T&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs // 这个没问题，因为 T 是一个 out-参数 // ……&#125; 一般原则是：当一个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C&lt;Base&gt; 可以安全地作为C&lt;Derived&gt;的超类。 简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。你可以认为 C 是 T 的生产者，而不是 T 的消费者。 out修饰符称为型变注解，并且由于它在类型参数声明处提供，所以我们讲声明处型变。这与 Java 的使用处型变相反，其类型用途通配符使得类型协变。 另外除了 out，Kotlin 又补充了一个型变注释：in。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable： 123456789interface Comparable&lt;in T&gt; &#123; operator fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型 // 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量 val y: Comparable&lt;Double&gt; = x // OK！&#125; 我们相信 in 和 out 两词是自解释的（因为它们已经在 C# 中成功使用很长时间了），因此上面提到的助记符不是真正需要的，并且可以将其改写为更高的目标： 存在性（The Existential） 转换：消费者 in, 生产者 out! :-) 类型投影使用处型变：类型投影将类型参数 T 声明为 out 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回 T！一个很好的例子是 Array： 1234class Array&lt;T&gt;(val size: Int) &#123; fun get(index: Int): T &#123; ///* …… */ &#125; fun set(index: Int, value: T) &#123; ///* …… */ &#125;&#125; 该类在 T 上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数： 12345fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) &#123; assert(from.size == to.size) for (i in from.indices) to[i] = from[i]&#125; 这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它： 123val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)val any = Array&lt;Any&gt;(3) &#123; \"\" &#125;copy(ints, any) // 错误：期望 (Array&lt;Any&gt;, Array&lt;Any&gt;) 这里我们遇到同样熟悉的问题：Array &lt;T&gt; 在 T 上是不型变的，因此 Array &lt;Int&gt; 和 Array &lt;Any&gt; 都不是另一个的子类型。为什么？ 再次重复，因为 copy 可能做坏事，也就是说，例如它可能尝试写一个 String 到 from，并且如果我们实际上传递一个 Int 的数组，一段时间后将会抛出一个 ClassCastException 异常。 那么，我们唯一要确保的是 copy() 不会做任何坏事。我们想阻止它写到 from，我们可以： 123fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123; // ……&#125; 这里发生的事情称为类型投影：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array&lt;? extends Object&gt;、但使用更简单些的方式。 你也可以使用 in 投影一个类型： 123fun fill(dest: Array&lt;in String&gt;, value: String) &#123; // ……&#125; Array&lt;in String&gt; 对应于 Java 的 Array&lt;? super String&gt;，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。 星投影有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型。 Kotlin 为此提供了所谓的星投影语法： 对于 Foo &lt;out T : TUpper&gt;，其中 T 是一个具有上界 TUpper 的协变类型参数，Foo &lt;*&gt; 等价于 Foo &lt;out TUpper&gt;。 这意味着当 T 未知时，你可以安全地从 Foo &lt;*&gt; _读取_ TUpper 的值。 对于 Foo &lt;in T&gt;，其中 T 是一个逆变类型参数，Foo &lt;*&gt; 等价于 Foo &lt;in Nothing&gt;。 这意味着当 T 未知时，没有什么可以以安全的方式写入 Foo &lt;*&gt;。 对于 Foo &lt;T : TUpper&gt;，其中 T 是一个具有上界 TUpper 的不型变类型参数，Foo&lt;*&gt; 对于读取值时等价于 Foo&lt;out TUpper&gt; 而对于写值时等价于 Foo&lt;in Nothing&gt;。 如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，我们可以想象以下星投影： Function&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;； Function&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;； Function&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;。 注意：星投影非常像 Java 的原始类型，但是安全。 泛型函数不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前： 1234567fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ……&#125;fun &lt;T&gt; T.basicToString() : String &#123; // 扩展函数 // ……&#125; 要调用泛型函数，在调用处函数名之后指定类型参数即可： 1val l = singletonList&lt;Int&gt;(1) 可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用： 1val l = singletonList(1) 泛型约束能够替换给定类型参数的所有可能类型的集合可以由泛型约束限制。 上界最常见的约束类型是与 Java 的 extends 关键字对应的 上界： 123fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; // ……&#125; 冒号之后指定的类型是上界：只有 Comparable&lt;T&gt; 的子类型可以替代 T。 例如： 12sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型 默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。如果同一类型参数需要多个上界，我们需要一个单独的 where-子句： 12345fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt; where T : CharSequence, T : Comparable&lt;T&gt; &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;&#125; 类型擦除Kotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。运行时泛型类型的实例不保留关于其类型实参的任何信息。其类型信息称为被擦除。例如，Foo&lt;Bar&gt; 与 Foo&lt;Baz?&gt; 的实例都会被擦除为Foo&lt;*&gt;。 因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建，并且编译器禁止这种 is 检测。 类型转换为带有具体类型参数的泛型类型，如 foo as List&lt;String&gt; 无法在运行时检测。当高级程序逻辑隐含了类型转换的类型安全而无法直接通过编译器推断时，可以使用这种非受检类型转换。编译器会对非受检类型转换发出警告，并且在运行时只对非泛型部分检测（相当于 foo as List&lt;*&gt;）。 泛型函数调用的类型参数也同样只在编译期检测。在函数体内部，类型参数不能用于类型检测，并且类型转换为类型参数（foo as T）也是非受检的。然而，内联函数的具体化的类型参数会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换，与上述泛型类型的实例具有相同限制。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"密封类","slug":"kotlin/reference/sealed-classes","date":"2018-05-17T02:31:00.000Z","updated":"2018-05-17T03:27:29.643Z","comments":true,"path":"kotlin/reference/sealed-classes.html","link":"","permalink":"http://oushiun.com/kotlin/reference/sealed-classes.html","excerpt":"密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前，该规则更加严格：子类必须嵌套在密封类声明的内部）。","text":"密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前，该规则更加严格：子类必须嵌套在密封类声明的内部）。 1234sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() （上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。） 一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。 密封类不允许有非 private 构造函数（其构造函数默认为 private）。 请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。 使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。 123456fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"数据类","slug":"kotlin/reference/data-classes","date":"2018-05-17T02:31:00.000Z","updated":"2018-05-17T03:23:31.701Z","comments":true,"path":"kotlin/reference/data-classes.html","link":"","permalink":"http://oushiun.com/kotlin/reference/data-classes.html","excerpt":"我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data： 1data class User(val name: String, val age: Int)","text":"我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data： 1data class User(val name: String, val age: Int) 编译器自动从主构造函数中声明的所有属性导出以下成员： equals()/hashCode() 对； toString() 格式是 &quot;User(name=John, age=42)&quot;； componentN() 函数 按声明顺序对应于所有属性； copy() 函数（见下文）。 为了确保生成的代码的一致性和有意义的行为，数据类必须满足以下要求： 主构造函数需要至少有一个参数； 主构造函数的所有参数需要标记为 val 或 var； 数据类不能是抽象、开放、密封或者内部的； （在 1.1 之前）数据类只能实现接口。 此外，成员生成遵循关于成员继承的这些规则： 如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数； 如果超类型具有 open 的 componentN() 函数并且返回兼容的类型，那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错； 从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且会在 Kotlin 1.3 中禁用。 不允许为 componentN() 以及 copy() 函数提供显式实现。 自 1.1 起，数据类可以扩展其他类（示例请参见密封类）。 在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。（参见构造函数）。 1data class User(val name: String = \"\", val age: Int = 0) 在类体中声明的属性请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排出一个属性，请将其声明在类体中： 123data class Person(val name: String) &#123; var age: Int = 0&#125; 在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等。 1234567891011121314151617data class Person(val name: String) &#123; var age: Int = 0&#125;fun main(args: Array&lt;String&gt;) &#123; //sampleStart val person1 = Person(\"John\") val person2 = Person(\"John\") person1.age = 10 person2.age = 20 //sampleEnd println(\"person1 == person2: $&#123;person1 == person2&#125;\") println(\"person1 with age $&#123;person1.age&#125;: $&#123;person1&#125;\") println(\"person2 with age $&#123;person2.age&#125;: $&#123;person2&#125;\")&#125; 复制在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样： 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 这让我们可以写： 12val jack = User(name = \"Jack\", age = 1)val olderJack = jack.copy(age = 2) 数据类和解构声明为数据类生成的 Component 函数 使它们可在解构声明中使用： 123val jane = User(\"Jane\", 35)val (name, age) = janeprintln(\"$name, $age years of age\") // 输出 \"Jane, 35 years of age\" 标准数据类标准库提供了 Pair 和 Triple。尽管在很多情况下命名数据类是更好的设计选择，因为它们通过为属性提供有意义的名称使代码更具可读性。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"扩展","slug":"kotlin/reference/extensions","date":"2018-05-17T02:24:03.000Z","updated":"2018-05-17T03:23:25.702Z","comments":true,"path":"kotlin/reference/extensions.html","link":"","permalink":"http://oushiun.com/kotlin/reference/extensions.html","excerpt":"Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。","text":"Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。 扩展函数声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。下面代码为 MutableList&lt;Int&gt; 添加一个swap 函数： 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象）现在，我们对任意 MutableList&lt;Int&gt; 调用该函数了： 12val l = mutableListOf(1, 2, 3)l.swap(0, 2) // “swap()”内部的“this”得到“l”的值 当然，这个函数对任何 MutableList&lt;T&gt; 起作用，我们可以泛化它： 12345fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。参见泛型函数。 扩展是静态解析的扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员，仅仅是可以通过该类型的变量用点表达式去调用这个新函数。 我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的，而不是由表达式运行时求值结果决定的。例如： 12345678910111213open class Cclass D: C()fun C.foo() = \"c\"fun D.foo() = \"d\"fun printFoo(c: C) &#123; println(c.foo())&#125;printFoo(D()) 这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。 如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字并且都适用给定的参数，这种情况总是取成员函数。例如： 12345class C &#123; fun foo() &#123; println(\"member\") &#125;&#125;fun C.foo() &#123; println(\"extension\") &#125; 如果我们调用 C 类型 c的 c.foo()，它将输出“member”，而不是“extension”。 当然，扩展函数重载同样名字但不同签名成员函数也完全可以： 12345class C &#123; fun foo() &#123; println(\"member\") &#125;&#125;fun C.foo(i: Int) &#123; println(\"extension\") &#125; 调用 C().foo(1) 将输出 “extension”。 可空接收者注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用，即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的 toString()：检测发生在扩展函数的内部。 123456fun Any?.toString(): String &#123; if (this == null) return \"null\" // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125; 扩展属性和函数类似，Kotlin 支持扩展属性： 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。 例如: 1val Foo.bar = 1 // 错误：扩展属性不能有初始化器 伴生对象的扩展如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性： 1234567class MyClass &#123; companion object &#123; &#125; // 将被称为 \"Companion\"&#125;fun MyClass.Companion.foo() &#123; // ……&#125; 就像伴生对象的其他普通成员，只需用类名作为限定符去调用他们 1MyClass.foo() 扩展的作用域大多数时候我们在顶层定义扩展，即直接在包里： 123package foo.barfun Baz.goo() &#123; …… &#125; 要使用所定义包之外的一个扩展，我们需要在调用方导入它： 123456789package com.example.usageimport foo.bar.goo // 导入所有名为“goo”的扩展 // 或者import foo.bar.* // 从“foo.bar”导入一切fun usage(baz: Baz) &#123; baz.goo()&#125; 更多信息参见导入 扩展声明为成员在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 ——其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法调用所在的接收者类型的实例称为 扩展接收者 。 12345678910111213141516class D &#123; fun bar() &#123; …… &#125;&#125;class C &#123; fun baz() &#123; …… &#125; fun D.foo() &#123; bar() // 调用 D.bar baz() // 调用 C.baz &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125; 对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的 this 语法。 12345class C &#123; fun D.foo() &#123; toString() // 调用 D.toString() this@C.toString() // 调用 C.toString() &#125; 声明为成员的扩展可以声明为 open 并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的。 123456789101112131415161718192021222324252627282930313233open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println(\"D.foo in C\") &#125; open fun D1.foo() &#123; println(\"D1.foo in C\") &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println(\"D.foo in C1\") &#125; override fun D1.foo() &#123; println(\"D1.foo in C1\") &#125;&#125;C().caller(D()) // 输出 \"D.foo in C\"C1().caller(D()) // 输出 \"D.foo in C1\" —— 分发接收者虚拟解析C().caller(D1()) // 输出 \"D.foo in C\" —— 扩展接收者静态解析 动机在 Java 中，我们将类命名为“*Utils”：FileUtils、StringUtils 等，著名的 java.util.Collections 也属于同一种命名方式。关于这些 Utils-类的不愉快的部分是代码写成这样： 12// JavaCollections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list)); 这些类名总是碍手碍脚的，我们可以通过静态导入达到这样效果： 12// Javaswap(list, binarySearch(list, max(otherList)), max(list)); 这会变得好一点，但是我们并没有从 IDE 强大的自动补全功能中得到帮助。如果能这样就更好了： 12// Javalist.swap(list.binarySearch(otherList.max()), list.max()); 但是我们不希望在 List 类内实现这些所有可能的方法，对吧？这时候扩展将会帮助我们。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"可见性修饰符","slug":"kotlin/reference/visibility-modifiers","date":"2018-05-17T02:18:56.000Z","updated":"2018-05-17T03:25:38.301Z","comments":true,"path":"kotlin/reference/visibility-modifiers.html","link":"","permalink":"http://oushiun.com/kotlin/reference/visibility-modifiers.html","excerpt":"类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。（getter 总是与属性有着相同的可见性。）在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。如果没有显式指定修饰符的话，默认可见性是 public。","text":"类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。（getter 总是与属性有着相同的可见性。）在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。如果没有显式指定修饰符的话，默认可见性是 public。 以下解释了这些修饰符如何应用到不同类型的声明作用域。 包函数、属性和类、对象和接口可以在顶层声明，即直接在包内： 12345// 文件名：example.ktpackage foofun baz() &#123;&#125;class Bar &#123;&#125; 如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见； 如果你声明为 private，它只会在声明它的文件内可见； 如果你声明为 internal，它会在相同模块内随处可见； protected 不适用于顶层声明。 注意：要使用另一包中可见的顶层声明，仍需将其导入进来。 例如: 123456789// 文件名：example.ktpackage fooprivate fun foo() &#123;&#125; // 在 example.kt 内可见public var bar: Int = 5 // 该属性随处可见 private set // setter 只在 example.kt 内可见internal val baz = 6 // 相同模块内可见 类和接口对于类内部声明的成员： private 意味着只在这个类内部（包含其所有成员）可见； protected 和 private一样 + 在子类中可见。 internal 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员； public 能见到类声明的任何客户端都可见其 public 成员。 注意 对于 Java 用户：Kotlin 中外部类不能访问内部类的 private 成员。 如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可见性。 例子: 123456789101112131415161718192021222324open class Outer &#123; private val a = 1 protected open val b = 2 internal val c = 3 val d = 4 // 默认 public protected class Nested &#123; public val e: Int = 5 &#125;&#125;class Subclass : Outer() &#123; // a 不可见 // b、c、d 可见 // Nested 和 e 可见 override val b = 5 // “b”为 protected&#125;class Unrelated(o: Outer) &#123; // o.a、o.b 不可见 // o.c 和 o.d 可见（相同模块） // Outer.Nested 不可见，Nested::e 也不可见&#125; 构造函数要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）： 1class C private constructor(a: Int) &#123; …… &#125; 这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见). 局部声明局部变量、函数和类不能有可见性修饰符。 模块可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说，一个模块是编译在一起的一套 Kotlin 文件： 一个 IntelliJ IDEA 模块； 一个 Maven 项目； 一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）； 一次 ＜ kotlinc ＞ Ant 任务执行所编译的一套文件。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"接口","slug":"kotlin/reference/interfaces","date":"2018-05-17T02:13:27.000Z","updated":"2018-05-17T03:23:46.770Z","comments":true,"path":"kotlin/reference/interfaces.html","link":"","permalink":"http://oushiun.com/kotlin/reference/interfaces.html","excerpt":"Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。","text":"Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。 使用关键字 interface 来定义接口 123456interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; 实现接口一个类或者对象可以实现一个或多个接口。 12345class Child : MyInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; 接口中的属性你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。 1234567891011121314interface MyInterface &#123; val prop: Int // 抽象的 val propertyWithImplementation: String get() = \"foo\" fun foo() &#123; print(prop) &#125;&#125;class Child : MyInterface &#123; override val prop: Int = 29&#125; 解决覆盖冲突实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如 123456789101112131415161718192021222324interface A &#123; fun foo() &#123; print(\"A\") &#125; fun bar()&#125;interface B &#123; fun foo() &#123; print(\"B\") &#125; fun bar() &#123; print(\"bar\") &#125;&#125;class C : A &#123; override fun bar() &#123; print(\"bar\") &#125;&#125;class D : A, B &#123; override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125; override fun bar() &#123; super&lt;B&gt;.bar() &#125;&#125; 上例中，接口 A 和 B 都定义了方法 foo() 和 bar()。 两者都实现了 foo(), 但是只有 B 实现了 bar() (bar() 在 A 中没有标记为抽象，因为没有方法体时默认为抽象）。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。 然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"属性和字段","slug":"kotlin/reference/properties","date":"2018-05-17T02:09:48.000Z","updated":"2018-05-17T03:24:01.879Z","comments":true,"path":"kotlin/reference/properties.html","link":"","permalink":"http://oushiun.com/kotlin/reference/properties.html","excerpt":"声明属性Kotlin 的类可以有属性。属性可以用关键字 var 声明为可变的，否则使用只读关键字 val。 1234567class Address &#123; var name: String = …… var street: String = …… var city: String = …… var state: String? = …… var zip: String = ……&#125;","text":"声明属性Kotlin 的类可以有属性。属性可以用关键字 var 声明为可变的，否则使用只读关键字 val。 1234567class Address &#123; var name: String = …… var street: String = …… var city: String = …… var state: String? = …… var zip: String = ……&#125; 要使用一个属性，只要用名称引用它即可，就像 Java 中的字段： 1234567fun copyAddress(address: Address): Address &#123; val result = Address() // Kotlin 中没有“new”关键字 result.name = address.name // 将调用访问器 result.street = address.street // …… return result&#125; Getters 与 Setters声明一个属性的完整语法是 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器（或者从其 getter 返回值，如下文所示）中推断出来，也可以省略。 例如: 12var allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 settervar initialized = 1 // 类型 Int、默认 getter 和 setter 一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val开始代替var 2、只读属性不允许 setter 12val simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化val inferredType = 1 // 类型 Int 、默认 getter 我们可以编写自定义的访问器，非常像普通函数，刚好在属性声明内部。这里有一个自定义 getter 的例子: 12val isEmpty: Boolean get() = this.size == 0 一个自定义的 setter 的例子: 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) // 解析字符串并赋值给其他属性 &#125; 按照惯例，setter 参数的名称是 value，但是如果你喜欢你可以选择一个不同的名称。 自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它： 1val isEmpty get() = this.size == 0 // 具有类型 Boolean 如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现，你可以定义访问器而不定义其实现: 12345var setterVisibility: String = \"abc\" private set // 此 setter 是私有的并且有默认实现var setterWithAnnotation: Any? = null @Inject set // 用 Inject 注解此 setter 幕后字段在 Kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供。这个幕后字段可以使用field标识符在访问器中引用： 1234var counter = 0 // 注意：这个初始器直接为幕后字段赋值 set(value) &#123; if (value &gt;= 0) field = value &#125; field 标识符只能用在属性的访问器内。 如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。 例如，下面的情况下， 就没有幕后字段： 12val isEmpty: Boolean get() = this.size == 0 幕后属性如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing property）： 12345678private var _table: Map&lt;String, Int&gt;? = nullpublic val table: Map&lt;String, Int&gt; get() &#123; if (_table == null) &#123; _table = HashMap() // 类型参数已推断出 &#125; return _table ?: throw AssertionError(\"Set to null by another thread\") &#125; 从各方面看，这正是与 Java 相同的方式。因为通过默认 getter 和 setter 访问私有属性会被优化，所以不会引入函数调用开销。 编译期常量已知值的属性可以使用 const 修饰符标记为 编译期常量。这些属性需要满足以下要求： 位于顶层或者是 object 的一个成员 用 String 或原生类型 值初始化 没有自定义 getter 这些属性可以用在注解中： 123const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() &#123; …… &#125; 延迟初始化属性与变量一般地，属性声明为非空类型必须在构造函数中初始化。然而，这经常不方便。例如：属性可以通过依赖注入来初始化，或者在单元测试的 setup 方法中初始化。 这种情况下，你不能在构造函数内提供一个非空初始器。但你仍然想在类体中引用该属性时避免空检查。 为处理这种情况，你可以用 lateinit 修饰符标记该属性： 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // 直接解引用 &#125;&#125; 该修饰符只能用于在类体中的属性（不是在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。 在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。 检测一个 lateinit var 是否已初始化（自 1.2 起）要检测一个 lateinit var 是否已经初始化过，请在该属性的引用上使用 .isInitialized： 123if (foo::bar.isInitialized) &#123; println(foo.bar)&#125; 此检测仅对可词法级访问的属性可用，即声明位于同一个类型内、位于其中一个外围类型中或者位于相同文件的顶层的属性。 覆盖属性参见覆盖属性 委托属性最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入）。另一方面，使用自定义 getter 和 setter 可以实现属性的任何行为。介于两者之间，属性如何工作有一些常见的模式。一些例子：惰性值、通过键值从映射读取、访问数据库、访问时通知侦听器等等。 这些常见行为可以通过使用委托属性实现为库。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"类和继承","slug":"kotlin/reference/classes","date":"2018-05-17T02:06:56.000Z","updated":"2018-05-17T03:22:44.708Z","comments":true,"path":"kotlin/reference/classes.html","link":"","permalink":"http://oushiun.com/kotlin/reference/classes.html","excerpt":"类Kotlin 中使用关键字 class 声明类 12class Invoice &#123;&#125; 类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的；如果一个类没有类体，可以省略花括号。 1class Empty","text":"类Kotlin 中使用关键字 class 声明类 12class Invoice &#123;&#125; 类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的；如果一个类没有类体，可以省略花括号。 1class Empty 构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。 12class Person constructor(firstName: String) &#123;&#125; 如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。 12class Person(firstName: String) &#123;&#125; 主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。 在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起： 12345678910111213141516171819//sampleStartclass InitOrderDemo(name: String) &#123; val firstProperty = \"First property: $name\".also(::println) init &#123; println(\"First initializer block that prints $&#123;name&#125;\") &#125; val secondProperty = \"Second property: $&#123;name.length&#125;\".also(::println) init &#123; println(\"Second initializer block that prints $&#123;name.length&#125;\") &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; InitOrderDemo(\"hello\")&#125; 请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用： 123class Customer(name: String) &#123; val customerKey = name.toUpperCase()&#125; 事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法： 123class Person(val firstName: String, val lastName: String, var age: Int) &#123; // ……&#125; 与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。 如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面： 1class Customer public @Inject constructor(name: String) &#123; …… &#125; 更多详情，参见可见性修饰符 次构造函数类也可以声明前缀有 constructor的次构造函数： 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可： 12345class Person(val name: String) &#123; constructor(name: String, parent: Person) : this(name) &#123; parent.children.add(this) &#125;&#125; 请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块： 123456789101112131415//sampleStartclass Constructors &#123; init &#123; println(\"Init block\") &#125; constructor(i: Int) &#123; println(\"Constructor\") &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; Constructors(1)&#125; 如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数： 12class DontCreateMe private constructor () &#123;&#125; 注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成一个额外的无参构造函数，它将使用默认值。这使得Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。 1class Customer(val customerName: String = \"\") 创建类的实例要创建一个类的实例，我们就像普通函数一样调用构造函数： 123val invoice = Invoice()val customer = Customer(\"Joe Smith\") 注意 Kotlin 并没有 new 关键字。 创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述。 类成员类可以包含： 构造函数和初始化块 函数 属性 嵌套类和内部类 对象声明 继承在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类： 1class Example // 从 Any 隐式继承 注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。更多细节请查阅Java 互操作性部分。 要声明一个显式的超类型，我们把类型放到类头的冒号之后： 123open class Base(p: Int)class Derived(p: Int) : Base(p) 类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。默认情况下，在 Kotlin 中所有的类都是 final，对应于《Effective Java》第三版书中的第 19 条：要么为继承而设计，并提供文档说明，要么就禁止继承。 如果派生类有一个主构造函数，其基类型可以（并且必须）用基类的主构造函数参数就地初始化。 如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数： 12345class MyView : View &#123; constructor(ctx: Context) : super(ctx) constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)&#125; 覆盖方法我们之前提到过，Kotlin 力求清晰显式。与 Java 不同，Kotlin 需要显式标注可覆盖的成员（我们称之为开放）和覆盖后的成员： 1234567open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; override fun v() &#123;&#125;&#125; Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数，不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。 标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字： 123open class AnotherDerived() : Base() &#123; final override fun v() &#123;&#125;&#125; 覆盖属性属性覆盖与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化器的属性或者具有 getter 方法的属性覆盖。 1234567open class Foo &#123; open val x: Int get() &#123; …… &#125;&#125;class Bar1 : Foo() &#123; override val x: Int = ……&#125; 你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。这是允许的，因为一个 val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法。 请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。 123456789interface Foo &#123; val count: Int&#125;class Bar1(override val count: Int) : Fooclass Bar2 : Foo &#123; override var count: Int = 0&#125; 派生类初始化顺序在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。 12345678910111213141516171819202122232425//sampleStartopen class Base(val name: String) &#123; init &#123; println(\"Initializing Base\") &#125; open val size: Int = name.length.also &#123; println(\"Initializing size in Base: $it\") &#125;&#125;class Derived( name: String, val lastName: String) : Base(name.capitalize().also &#123; println(\"Argument for Base: $it\") &#125;) &#123; init &#123; println(\"Initializing Derived\") &#125; override val size: Int = (super.size + lastName.length).also &#123; println(\"Initializing size in Derived: $it\") &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"Constructing Derived(\\\"hello\\\", \\\"world\\\")\") val d = Derived(\"hello\", \"world\")&#125; 这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。 调用超类实现派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现： 12345678910111213open class Foo &#123; open fun f() &#123; println(\"Foo.f()\") &#125; open val x: Int get() = 1&#125;class Bar : Foo() &#123; override fun f() &#123; super.f() println(\"Bar.f()\") &#125; override val x: Int get() = super.x + 1&#125; 在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer： 1234567891011class Bar : Foo() &#123; override fun f() &#123; /* …… */ &#125; override val x: Int get() = 0 inner class Baz &#123; fun g() &#123; super@Bar.f() // 调用 Foo 实现的 f() println(super@Bar.x) // 使用 Foo 实现的 x 的 getter &#125; &#125;&#125; 覆盖规则在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super&lt;Base&gt;： 1234567891011121314151617open class A &#123; open fun f() &#123; print(\"A\") &#125; fun a() &#123; print(\"a\") &#125;&#125;interface B &#123; fun f() &#123; print(\"B\") &#125; // 接口成员默认就是“open”的 fun b() &#123; print(\"b\") &#125;&#125;class C() : A(), B &#123; // 编译器要求覆盖 f()： override fun f() &#123; super&lt;A&gt;.f() // 调用 A.f() super&lt;B&gt;.f() // 调用 B.f() &#125;&#125; 同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f()并且提供我们自己的实现来消除歧义。 抽象类类和其中的某些成员可以声明为 abstract。抽象成员在本类中可以不用实现。需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。 我们可以用一个抽象成员覆盖一个非抽象的开放成员 1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 伴生对象与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。 如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。 更具体地讲，如果在你的类内声明了一个伴生对象，你就可以使用像在 Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"类与对象","slug":"后端/Kotlin/类与对象","permalink":"http://oushiun.com/categories/后端/Kotlin/类与对象/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"返回和跳转","slug":"kotlin/reference/returns","date":"2018-05-15T10:00:56.000Z","updated":"2018-05-15T10:00:57.121Z","comments":true,"path":"kotlin/reference/returns.html","link":"","permalink":"http://oushiun.com/kotlin/reference/returns.html","excerpt":"Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。","text":"Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 所有这些表达式都可以用作更大表达式的一部分： 1val s = person.name ?: return 这些表达式的类型是 Nothing 类型。 Break 与 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。要为一个表达式加标签，我们只要在其前加标签即可。 123loop@ for (i in 1..100) &#123; // ……&#125; 现在，我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。continue 继续标签指定的循环的下一次迭代。 标签处返回Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。标签限制的 return 允许我们从外层函数返回。最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候： 12345678910111213//sampleStartfun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return // 非局部直接返回到 foo() 的调用者 print(it) &#125; println(\"this point is unreachable\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; foo()&#125; 这个 return 表达式从最直接包围它的函数即 foo 中返回。（注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。）如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。 12345678910111213//sampleStartfun foo() &#123; listOf(1, 2, 3, 4, 5).forEach lit@&#123; if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环 print(it) &#125; print(\" done with explicit label\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; foo()&#125; 现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。该标签与接受该 lambda 的函数同名。 12345678910111213//sampleStartfun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环 print(it) &#125; print(\" done with implicit label\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; foo()&#125; 或者，我们用一个匿名函数替代 lambda 表达式。匿名函数内部的 return 语句将从该匿名函数自身返回 12345678910111213//sampleStartfun foo() &#123; listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) &#123; if (value == 3) return // 局部返回到匿名函数的调用者，即 forEach 循环 print(value) &#125;) print(\" done with anonymous function\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; foo()&#125; 请注意，前文三个示例中使用的局部返回类似于在常规循环中使用 continue。并没有 break 的直接等价形式，不过可以通过增加另一层嵌套 lambda 表达式并从其中非局部返回来模拟： 123456789101112131415//sampleStartfun foo() &#123; run loop@&#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@loop // 从传入 run 的 lambda 表达式非局部返回 print(it) &#125; &#125; print(\" done with nested loop\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; foo()&#125; 当要返一个回值的时候，解析器优先选用标签限制的 return，即 1return@a 1 意为“从标签 @a 返回 1”，而不是“返回一个标签标注的表达式 (@a 1)”。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"基础","slug":"后端/Kotlin/基础","permalink":"http://oushiun.com/categories/后端/Kotlin/基础/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"控制流：if、when、for、while","slug":"kotlin/reference/control-flow","date":"2018-05-15T09:47:44.000Z","updated":"2018-05-15T09:48:26.145Z","comments":true,"path":"kotlin/reference/control-flow.html","link":"","permalink":"http://oushiun.com/kotlin/reference/control-flow.html","excerpt":"If 表达式在 Kotlin 中，if 是一个表达式，即它会返回一个值。因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。","text":"If 表达式在 Kotlin 中，if 是一个表达式，即它会返回一个值。因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。 1234567891011121314// 传统用法var max = aif (a &lt; b) max = b// With elsevar max: Intif (a &gt; b) &#123; max = a&#125; else &#123; max = b&#125;// 作为表达式val max = if (a &gt; b) a else b if的分支可以是代码块，最后的表达式作为该块的值： 1234567val max = if (a &gt; b) &#123; print(\"Choose a\") a&#125; else &#123; print(\"Choose b\") b&#125; 如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支。 参见 if 语法。 When 表达式when 取代了类 C 语言的 switch 操作符。其最简单的形式如下： 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; // 注意这个块 print(\"x is neither 1 nor 2\") &#125;&#125; when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用，则忽略个别分支的值。（像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。） 如果其他分支都不满足条件将会求值 else 分支。如果 when 作为一个表达式使用，则必须有 else 分支，除非编译器能够检测出所有的可能情况都已经覆盖了。 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 1234when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125; 我们可以用任意表达式（而不只是常量）作为分支条件 1234when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125; 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中： 123456when (x) &#123; in 1..10 -&gt; print(\"x is in the range\") in validNumbers -&gt; print(\"x is valid\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125; 另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意：由于智能转换，你可以访问该类型的方法和属性而无需任何额外的检测。 1234fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125; when 也可以用来取代 if-else if链。如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支： 12345when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; 参见 when 语法。 For 循环for 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。语法如下： 1for (item in collection) print(item) 循环体可以是一个代码块。 123for (item: Int in ints) &#123; // ……&#125; 如上所述，for 可以循环遍历任何提供了迭代器的对象。即： 有一个成员函数或者扩展函数 iterator()，它的返回类型 有一个成员函数或者扩展函数 next()，并且 有一个成员函数或者扩展函数 hasNext() 返回 Boolean。 这三个函数都需要标记为 operator。 如需在数字区间上迭代，请使用区间表达式: 12345678910fun main(args: Array&lt;String&gt;) &#123;//sampleStartfor (i in 1..3) &#123; println(i)&#125;for (i in 6 downTo 0 step 2) &#123; println(i)&#125;//sampleEnd&#125; 对区间或者数组的 for 循环会被编译为并不创建迭代器的基于索引的循环。 如果你想要通过索引遍历一个数组或者一个 list，你可以这么做： 12345678fun main(args: Array&lt;String&gt;) &#123;val array = arrayOf(\"a\", \"b\", \"c\")//sampleStartfor (i in array.indices) &#123; println(array[i])&#125;//sampleEnd&#125; 或者你可以用库函数 withIndex： 12345678fun main(args: Array&lt;String&gt;) &#123;val array = arrayOf(\"a\", \"b\", \"c\")//sampleStartfor ((index, value) in array.withIndex()) &#123; println(\"the element at $index is $value\")&#125;//sampleEnd&#125; 参见for 语法。 While 循环while 和 do..while 照常使用 1234567while (x &gt; 0) &#123; x--&#125;do &#123; val y = retrieveData()&#125; while (y != null) // y 在此处可见 参见while 语法. 循环中的 Break 和 continue在循环中 Kotlin 支持传统的 break 和 continue 操作符。参见返回和跳转。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"基础","slug":"后端/Kotlin/基础","permalink":"http://oushiun.com/categories/后端/Kotlin/基础/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"包和导入","slug":"kotlin/reference/packages","date":"2018-05-15T09:14:17.000Z","updated":"2018-05-16T07:29:05.271Z","comments":true,"path":"kotlin/reference/packages.html","link":"","permalink":"http://oushiun.com/kotlin/reference/packages.html","excerpt":"包源文件通常以包声明开头: 1234567package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;// …… 源文件所有内容（无论是类还是函数）都包含在声明的包内。所以上例中 baz() 的全名是 foo.bar.baz、Goo 的全名是 foo.bar.Goo。 如果没有指明包，该文件的内容属于无名字的默认包。","text":"包源文件通常以包声明开头: 1234567package foo.barfun baz() &#123;&#125;class Goo &#123;&#125;// …… 源文件所有内容（无论是类还是函数）都包含在声明的包内。所以上例中 baz() 的全名是 foo.bar.baz、Goo 的全名是 foo.bar.Goo。 如果没有指明包，该文件的内容属于无名字的默认包。 默认导入有多个包会默认导入到每个 Kotlin 文件中： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* （自 1.1 起） kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 根据目标平台还会导入额外的包： JVM: java.lang.* kotlin.jvm.* JS: kotlin.js.* 导入除了默认导入之外，每个文件可以包含它自己的导入指令。导入语法在语法中讲述。 可以导入一个单独的名字，如. 1import foo.Bar // 现在 Bar 可以不用限定符访问 也可以导入一个作用域下的所有内容（包、类、对象等）: 1import foo.* // “foo”中的一切都可访问 如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义： 12import foo.Bar // Bar 可访问import bar.Bar as bBar // bBar 代表“bar.Bar” 关键字 import 并不仅限于导入类；也可用它来导入其他声明： 顶层函数及属性； 在对象声明中声明的函数和属性; 枚举常量。 与 Java 不同，Kotlin 没有单独的“import static”语法； 所有这些声明都用 import 关键字导入。 顶层声明的可见性如果顶层声明是 private 的，它是声明它的文件所私有的（参见 可见性修饰符）。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"Getting Started","slug":"后端/Kotlin/Getting-Started","permalink":"http://oushiun.com/categories/后端/Kotlin/Getting-Started/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"基本类型","slug":"kotlin/reference/basic-types","date":"2018-05-15T09:01:18.000Z","updated":"2018-05-17T03:34:26.169Z","comments":true,"path":"kotlin/reference/basic-types.html","link":"","permalink":"http://oushiun.com/kotlin/reference/basic-types.html","excerpt":"在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数和属性。一些类型可以有特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。","text":"在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数和属性。一些类型可以有特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 数字Kotlin 处理数字在某种程度上接近 Java，但是并不完全相同。例如，对于数字没有隐式拓宽转换（如 Java 中 int 可以隐式转换为long——译者注)，另外有些情况的字面值略有不同。 Kotlin 提供了如下的内置类型来表示数字（与 Java 很相近）： Type Bit width Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 注意在 Kotlin 中字符不是数字 字面常量数值常量字面值有以下几种: 十进制: 123 Long 类型用大写 L 标记: 123L 十六进制: 0x0F 二进制: 0b00001011 注意: 不支持八进制 Kotlin 同样支持浮点数的常规表示方法: 默认 double：123.5、123.5e10 Float 用 f 或者 F 标记: 123.5f 数字字面值中的下划线（自 1.1 起）你可以使用下划线使数字常量更易读： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 表示方式在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int?）或泛型。后者情况下会把数字装箱。 注意数字装箱不必保留同一性: 12345val a: Int = 10000print(a === a) // 输出“true”val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA === anotherBoxedA) // ！！！输出“false”！！！ 另一方面，它保留了相等性: 12345val a: Int = 10000print(a == a) // 输出“true”val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA == anotherBoxedA) // 输出“true” 显式转换由于不同的表示方式，较小类型并不是较大类型的子类型。如果它们是的话，就会出现下述问题： 1234// 假想的代码，实际上并不能编译：val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)print(a == b) // 惊！这将输出“false”鉴于 Int 的 equals() 会检测另一个是否也为 Long 所以相等性会在所有地方悄无声息地失去，更别说同一性了。 因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以显式转换来拓宽数字 1val i: Int = b.toInt() // OK: 显式拓宽 每个数字类型支持如下的转换: toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 缺乏隐式类型转换并不显著，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如： 1val l = 1L + 3 // Long + Int =&gt; Long 运算Kotlin支持数字运算的标准集，运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。参见运算符重载。 对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如: 1val x = (1 shl 2) and 0x000FF000 这是完整的位运算列表（只用于 Int 和 Long）： shl(bits) – 有符号左移 (Java 的 &lt;&lt;) shr(bits) – 有符号右移 (Java 的 &gt;&gt;) ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;) and(bits) – 位与 or(bits) – 位或 xor(bits) – 位异或 inv() – 位非 浮点数比较本节讨论的浮点数操作如下： 相等性检测：a == b 与 a != b 比较操作符：a &lt; b、 a &gt; b、 a &lt;= b、 a &gt;= b 区间实例以及区间检测：a..b、 x in a..b、 x !in a..b 当其中的操作数 a 与 b 都是静态已知的 Float 或 Double 或者它们对应的可空类型（声明为该类型，或者推断为该类型，或者智能类型转换的结果是该类型），两数字所形成的操作或者区间遵循 IEEE 754 浮点运算标准。 然而，为了支持泛型场景并提供全序支持，当这些操作符并非静态类型为浮点数（例如是 Any、 Comparable&lt;……&gt;、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现： 认为 NaN 与其自身相等 认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大 认为 -0.0 小于 0.0 字符字符用 Char 类型表示。它们不能直接当作数字 12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不兼容 // …… &#125;&#125; 字符字面值用单引号括起来: &#39;1&#39;。特殊字符可以用反斜杠转义。支持这几个转义序列：\\t、 \\b、\\n、\\r、\\&#39;、\\&quot;、\\\\ 和 \\$。编码其他字符要用 Unicode 转义序列语法：&#39;\\uFF00&#39;。 我们可以显式把字符转换为 Int 数字： 12345fun decimalDigitValue(c: Char): Int &#123; if (c !in '0'..'9') throw IllegalArgumentException(\"Out of range\") return c.toInt() - '0'.toInt() // 显式转换为数字&#125; 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。 布尔布尔用 Boolean 类型表示，它有两个值：true 和 false。 若需要可空引用布尔会被装箱。 内置的布尔运算有： || – 短路逻辑或 &amp;&amp; – 短路逻辑与 ! - 逻辑非 数组数组在 Kotlin 中使用 Array 类来表示，它定义了 get 和 set 函数（按照运算符重载约定这会转变为 []）和 size 属性，以及一些其他有用的成员函数： 12345678class Array&lt;T&gt; private constructor() &#123; val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator&lt;T&gt; // ……&#125; 我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。 另一个选项是用接受数组大小和一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值： 12// 创建一个 Array&lt;String&gt; 初始化为 [\"0\", \"1\", \"4\", \"9\", \"16\"]val asc = Array(5, &#123; i -&gt; (i * i).toString() &#125;) 如上所述，[] 运算符代表调用成员函数 get() 和 set()。 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array&lt;String&gt; 赋值给 Array&lt;Any&gt;，以防止可能的运行时失败（但是你可以使用 Array&lt;out Any&gt;,参见类型投影）。 Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、ShortArray、IntArray 等等。这些类和 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法: 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] 字符串字符串用 String 类型表示。字符串是不可变的。字符串的元素——字符可以使用索引运算符访问: s[i]。可以用 for 循环迭代字符串: 12345678fun main(args: Array&lt;String&gt;) &#123;val str = \"abcd\"//sampleStartfor (c in str) &#123; println(c)&#125;//sampleEnd&#125; 可以用 + 操作符连接字符串。这也适用于连接字符串与其他类型的值，只要表达式中的第一个元素是字符串： 123456fun main(args: Array&lt;String&gt;) &#123;//sampleStartval s = \"abc\" + 1println(s + \"def\")//sampleEnd&#125; 请注意，在大多数情况下，优先使用字符串模板或原始字符串而不是字符串连接。 字符串字面值Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，以及原始字符串可以包含换行和任意文本。转义字符串很像 Java 字符串: 1val s = \"Hello, world!\\n\" 转义采用传统的反斜杠方式。参见上面的 字符 查看支持的转义序列。 原始字符串 使用三个引号（&quot;&quot;&quot;）分界符括起来，内部没有转义并且可以包含换行和任何其他字符: 1234val text = \"\"\" for (c in \"foo\") print(c)\"\"\" 你可以通过 trimMargin() 函数去除前导空格： 123456val text = \"\"\" |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) \"\"\".trimMargin() 默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。 字符串模板字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。模板表达式以美元符（$）开头，由一个简单的名字构成: 123456fun main(args: Array&lt;String&gt;) &#123;//sampleStartval i = 10println(\"i = $i\") // 输出“i = 10”//sampleEnd&#125; 或者用花括号括起来的任意表达式: 123456fun main(args: Array&lt;String&gt;) &#123;//sampleStartval s = \"abc\"println(\"$s.length is $&#123;s.length&#125;\") // 输出“abc.length is 3”//sampleEnd&#125; 原始字符串和转义字符串内部都支持模板。如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 123val price = \"\"\"$&#123;'$'&#125;9.99\"\"\"","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"基础","slug":"后端/Kotlin/基础","permalink":"http://oushiun.com/categories/后端/Kotlin/基础/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"编码规范","slug":"kotlin/reference/coding-conventions","date":"2018-05-15T08:50:55.000Z","updated":"2018-05-17T03:34:44.791Z","comments":true,"path":"kotlin/reference/coding-conventions.html","link":"","permalink":"http://oushiun.com/kotlin/reference/coding-conventions.html","excerpt":"应用风格指南如需根据本风格指南配置 IntelliJ 格式化程序，请安装 Kotlin 插件 1.2.20 或更高版本，转到“Settings | Editor | Code Style | Kotlin”，点击右上角的“Set from…”链接，并从菜单中选择“Predefined style / Kotlin style guide”。 如需验证代码已按风格指南格式化，请转到探查设置并启用“Kotlin | Style issues | File is not formatted according to project settings”探查项。验证风格指南中描述的其他问题（如命名约定）的附加探查项默认已启用。","text":"应用风格指南如需根据本风格指南配置 IntelliJ 格式化程序，请安装 Kotlin 插件 1.2.20 或更高版本，转到“Settings | Editor | Code Style | Kotlin”，点击右上角的“Set from…”链接，并从菜单中选择“Predefined style / Kotlin style guide”。 如需验证代码已按风格指南格式化，请转到探查设置并启用“Kotlin | Style issues | File is not formatted according to project settings”探查项。验证风格指南中描述的其他问题（如命名约定）的附加探查项默认已启用。 源代码组织目录结构在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下，并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中）。 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构（例如，如果项目中的所有代码都位于“org.example.kotlin”包及其子包中，那么“org.example.kotlin”包的文件应该直接放在源代码根目录下，而“org.example.kotlin.foo.bar”中的文件应该放在源代码根目录下的“foo/bar”子目录中）。 源文件名称如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明，那么选择一个描述该文件所包含内容的名称，并以此命名该文件。使用首字母大写的驼峰风格（例如 ProcessDeclarations.kt）。 文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。 源文件组织鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中，只要这些声明在语义上彼此紧密关联并且文件保持合理大小（不超过几百行）。 特别是在为类定义与类的所有客户都相关的扩展函数时，请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存“Foo 的所有扩展函数”而创建文件。 类布局通常，一个类的内容按以下顺序排列： 属性声明与初始化块 次构造函数 方法声明 伴生对象 不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。 将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。 接口实现布局在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要，还要插入用于实现的额外的私有方法） 重载布局在类中总是将重载放在一起。 命名规则Kotlin 遵循 Java 命名约定。尤其是： 包的名称总是小写且不使用下划线（org.example.myproject）。通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰（org.example.myProject）。 类和对象的名称以大写字母开头并使用驼峰： 123open class DeclarationProcessor &#123; …… &#125;object EmptyDeclarationProcessor : DeclarationProcessor() &#123; …… &#125; 函数名函数、属性与局部变量的名称以小写字母开头、使用驼峰而不使用下划线： 12fun processDeclarations() &#123; …… &#125;var declarationCount = …… 例外：用于创建类实例的工厂函数可以与要创建的类具有相同的名称： 12345abstract class Foo &#123; …… &#125;class FooImpl : Foo &#123; …… &#125;fun Foo(): Foo &#123; return FooImpl(……) &#125; 测试方法的名称当且仅当在测试中，可以使用反引号括起来的带空格的方法名。（请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。 1234567class MyTestCase &#123; @Test fun `ensure everything works`() &#123; &#125; @Test fun ensureEverythingWorks_onAndroid() &#123; &#125;&#125; 属性名常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称： 12const val MAX_COUNT = 8val USER_NAME_FIELD = \"UserName\" 保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用常规驼峰名称： 1val mutableCollection: MutableSet&lt;String&gt; = HashSet() 保存单例对象引用的属性的名称可以使用与 object 声明相同的命名风格： 1val PersonComparator: Comparator&lt;Person&gt; = ... 对于枚举常量，可以使用大写、下划线分隔的名称（enum class Color { RED, GREEN }）也可使用以大写字母开头的常规驼峰名称，具体取决于用途。 幕后属性的名称如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀： 123456class C &#123; private val _elementList = mutableListOf&lt;Element&gt;() val elementList: List&lt;Element&gt; get() = _elementList&#125; 选择好名称类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。 方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。 名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词（Manager、 Wrapper 等）。 当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）；而如果缩写更长一些，就只大写首首字母（XmlFormatter、 HttpInputStream）。 格式化在大多数情况下，Kotlin 遵循 Java 编码规范。 使用 4 个空格缩进。不要使用 tab。 对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构垂直对齐的单独一行。 12345if (elements != null) &#123; for (element in elements) &#123; // …… &#125;&#125; （注意：在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。） 横向空白在二元操作符左右留空格（a + b）。例外：不要在“range to”操作符（0..i）左右留空格。 不要在一元运算符左右留空格（a++） 在控制流关键字（if、 when、 for 以及 while）与相应的左括号之间留空格。 不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。 1234567class A(val x: Int)fun foo(x: Int) &#123; &#125;fun bar() &#123; foo(1)&#125; 绝不在 (、 [ 之后或者 ]、 ) 之前留空格。 绝不在. 或者 ?. 左右留空格：foo.bar().filter { it &gt; 2 }.joinToString(), foo?.bar() 在 // 之后留一个空格：// 这是一条注释 不要在用于指定类型参数的尖括号前后留空格：class Map&lt;K, V&gt; { …… } 不要在 :: 前后留空格：Foo::class、 String::length 不要在用于标记可空类型的 ? 前留空格：String? 作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。 冒号在以下场景中的 : 之前留一个空格： 当它用于分隔类型与超类型时； 当委托给一个超类的构造函数或者同一类的另一个构造函数时； 在 object 关键字之后。 而当分隔声明与其类型时，不要在 : 之前留空格。 在 : 之后总要留一个空格。 1234567891011abstract class Foo&lt;out T : Any&gt; : IFoo &#123; abstract fun foo(a: Int): T&#125;class FooImpl : Foo() &#123; constructor(x: String) : this(x) &#123; //…… &#125; val x = object : IFoo &#123; …… &#125;&#125; 类头格式化具有少数主构造函数参数的类可以写成一行： 1class Person(id: Int, name: String) 具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与左括号位于同一行： 12345678class Person( id: Int, name: String, surname: String) : Human(id, name) &#123; // ……&#125; 对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中： 123456789class Person( id: Int, name: String, surname: String) : Human(id, name), KotlinMaker &#123; // ……&#125; 对于具有很长超类型列表的类，在冒号后面换行，并垂直对齐所有超类型名： 1234567class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne &#123; fun foo() &#123;&#125;&#125; 为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行（如上例所示）或者将左花括号放在独立行上： 1234567class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne&#123; fun foo() &#123;&#125;&#125; 构造函数参数使用常规缩进（4 个空格）。 理由：这确保了在主构造函数中声明的属性与在类体中声明的属性具有相同的缩进。 修饰符如果一个声明有多个修饰符，请始终按照以下顺序安放： 12345678910111213141516public / protected / private / internalexpect / actualfinal / open / abstract / sealed / constexternaloverridelateinittailrecvarargsuspendinnerenum / annotationcompanioninlineinfixoperatordata 将所有注解放在修饰符前： 12@Named(\"Foo\")private val foo: Foo 除非你在编写库，否则请省略多余的修饰符（例如 public）。 注解格式化注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进： 12@Target(AnnotationTarget.PROPERTY)annotation class JsonExclude 无参数的注解可以放在同一行： 12@JsonExclude @JvmFieldvar x: String 无参数的单个注解可以与相应的声明放在同一行： 1@Test fun foo() &#123; …… &#125; 文件注解文件注解位于文件注释（如果有的话）之后、package 语句之前，并且用一个空白行与 package 分开（为了强调其针对文件而不是包）。 1234/** 授权许可、版权以及任何其他内容 */@file:JvmName(\"FooBar\")package foo.bar 函数格式化如果函数签名不适合单行，请使用以下语法： 123456fun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType): ReturnType &#123; // 函数体&#125; 函数参数使用常规缩进（4 个空格）。 理由：与构造函数参数一致 对于由单个表达式构成的函数体，首选使用表达式形式。 12345fun foo(): Int &#123; // 较差 return 1&#125;fun foo() = 1 // 良好 表达式函数体格式化如果函数的表达式函数体与函数声明不适合放在同一行，那么将 = 留在第一行。将表达式函数体缩进 4 个空格。 12fun f(x: String) = x.length 属性格式化对于非常简单的只读属性，请考虑单行格式： 1val isEmpty: Boolean get() = size == 0 对于更复杂的属性，总是将 get 与 set 关键字放在不同的行上： 1234val foo: String get() &#123; // …… &#125; 对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格： 12private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file) 格式化控制流语句如果 if 或 when 语句的条件有多行，那么在语句体外边总是使用大括号。将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。将该条件的右圆括号与左花括号放在单独一行： 12345if (!component.isSyncing &amp;&amp; !hasAnyKotlinRuntimeInScope(module)) &#123; return createKotlinNotConfiguredPanel(module)&#125; 理由：对齐整齐并且将条件与语句体分隔清楚 将 else、 catch、 finally 关键字以及 do/while 循环的 while 关键字与之前的花括号放在相同的行上： 1234567891011if (condition) &#123; // 主体&#125; else &#123; // else 部分&#125;try &#123; // 主体&#125; finally &#123; // 清理&#125; 在 when 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开： 123456789private fun parsePropertyValue(propName: String, token: Token) &#123; when (token) &#123; is Token.ValueToken -&gt; callback.visitValue(propName, token.value) Token.LBRACE -&gt; &#123; // …… &#125; &#125;&#125; 将短分支放在与条件相同的行上，无需花括号。 1234when (foo) &#123; true -&gt; bar() // 良好 false -&gt; &#123; baz() &#125; // 较差&#125; 方法调用格式化在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。将密切相关的多个参数分在同一行。 12345drawSquare( x = 10, y = 10, width = 100, height = 100, fill = true) 在分隔参数名与值的 = 左右留空格。 链式调用换行当对链式调用换行时，将 . 字符或者 ?. 操作符放在下一行，并带有单倍缩进： 1234val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile &#123; it is PsiComment || it is PsiWhiteSpace &#125; 调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。 Lambda 表达式格式化在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。 1list.filter &#123; it &gt; 10 &#125; 如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格： 12345fun foo() &#123; ints.forEach lit@&#123; // …… &#125;&#125; 在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符： 123appendCommaSeparated(properties) &#123; prop -&gt; val propertyValue = prop.get(obj) // ……&#125; 如果参数列表太长而无法放在一行上，请将箭头放在单独一行： 123456foo &#123; context: Context, environment: Env -&gt; context.configureEnv(environment)&#125; 文档注释对于较长的文档注释，将开头 /** 放在一个独立行中，并且每个后续行都以星号开头： 1234/** * 这是一条多行 * 文档注释。 */ 简短注释可以放在一行内： 1/** 这是一条简短文档注释。 */ 通常，避免使用 @param 与 @return 标记。而是将参数与返回值的描述直接合并到文档注释中，并在提到参数的任何地方加上参数链接。只有当需要不适合放进主文本流程的冗长描述时才应使用 @param 与 @return。 123456789101112131415// 避免这样：/** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */fun abs(number: Int) = ……// 而要这样：/** * Returns the absolute value of the given [number]. */fun abs(number: Int) = …… 避免重复结构一般来说，如果 Kotlin 中的某种语法结构是可选的并且被 IDE高亮为冗余的，那么应该在代码中省略之。为了清楚起见，不要在代码中保留不必要的语法元素。 Unit如果函数返回 Unit，那么应该省略返回类型： 123fun foo() &#123; // 这里省略了“: Unit”&#125; 分号尽可能省略分号。 字符串模版将简单变量传入到字符串模版中时不要使用花括号。只有用到更长表达式时才使用花括号。 1println(\"$name has $&#123;children.size&#125; children\") 语言特性的惯用法不可变性Prefer using immutable data to mutable. Always declare local variables and properties as val rather than var ifthey are not modified after initialization. Always use immutable collection interfaces (Collection, List, Set, Map) to declare collections which are notmutated. When using factory functions to create collection instances, always use functions that return immutablecollection types when possible: 1234567891011// Bad: use of mutable collection type for value which will not be mutatedfun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) &#123; ... &#125;// Good: immutable collection type used insteadfun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) &#123; ... &#125;// Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection typeval allowedValues = arrayListOf(\"a\", \"b\", \"c\")// Good: listOf() returns List&lt;T&gt;val allowedValues = listOf(\"a\", \"b\", \"c\") 默认参数值Prefer declaring functions with default parameter values to declaring overloaded functions. 123456// Badfun foo() = foo(\"a\")fun foo(a: String) &#123; ... &#125;// Goodfun foo(a: String = \"a\") &#123; ... &#125; 类型别名If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defininga type alias for it: 12typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unittypealias PersonIndex = Map&lt;String, Person&gt; Lambda 表达式参数In lambdas which are short and not nested, it’s recommended to use the it convention instead of declaring the parameterexplicitly. In nested lambdas with parameters, parameters should be always declared explicitly. 在 lambda 表达式中返回Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point.If that’s not possible or not clear enough, consider converting the lambda into an anonymous function. Do not use a labeled return for the last statement in a lambda. 命名参数Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of Boolean type,unless the meaning of all parameters is absolutely clear from context. 1drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true) 使用条件语句Prefer using the expression form of try, if and when. Examples: 123456return if (x) foo() else bar()return when(x) &#123; 0 -&gt; \"zero\" else -&gt; \"nonzero\"&#125; The above is preferable to: 123456789if (x) return foo()else return bar()when(x) &#123; 0 -&gt; return \"zero\" else -&gt; return \"nonzero\"&#125; if 还是 whenPrefer using if for binary conditions instead of when. Instead of 1234when (x) &#123; null -&gt; ... else -&gt; ...&#125; use if (x == null) ... else ... Prefer using when if there are three or more options. Using nullable Boolean values in conditionsIf you need to use a nullable Boolean in a conditional statement, use if (value == true) or if (value == false) checks. 使用循环Prefer using higher-order functions (filter, map etc.) to loops. Exception: forEach (prefer using a regular for loop instead,unless the receiver of forEach is nullable or forEach is used as part of a longer call chain). When making a choice between a complex expression using multiple higher-order functions and a loop, understand the costof the operations being performed in each case and keep performance considerations in mind. 区间上循环Use the until function to loop over an open range: 12for (i in 0..n - 1) &#123; ... &#125; // badfor (i in 0 until n) &#123; ... &#125; // good 使用字符串Prefer using string templates to string concatenation. Prefer to use multiline strings instead of embedding \\n escape sequences into regular string literals. To maintain indentation in multiline strings, use trimIndent when the resulting string does not require any internalindentation, or trimMargin when internal indentation is required: 123456assertEquals(\"\"\"Foo Bar\"\"\".trimIndent(), value)val a = \"\"\"if(a &gt; 1) &#123; | return a |&#125;\"\"\".trimMargin() 函数还是属性In some cases functions with no arguments might be interchangeable with read-only properties.Although the semantics are similar, there are some stylistic conventions on when to prefer one to another. Prefer a property over a function when the underlying algorithm: does not throw is cheap to calculate (or caсhed on the first run) returns the same result over invocations if the object state hasn’t changed 使用扩展函数Use extension functions liberally. Every time you have a function that works primarily on an object, consider making itan extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility ofextension functions as much as it makes sense. As necessary, use local extension functions, member extension functions,or top-level extension functions with private visibility. 使用中缀函数Declare a function as infix only when it works on two objects which play a similar role. Good examples: and, to, zip.Bad example: add. Don’t declare a method as infix if it mutates the receiver object. 工厂函数If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct namemaking it clear why the behavior of the factory function is special. Only if there is really no special semantics,you can use the same name as the class. Example: 12345class Point(val x: Double, val y: Double) &#123; companion object &#123; fun fromPolar(angle: Double, radius: Double) = Point(...) &#125;&#125; If you have an object with multiple overloaded constructors that don’t call different superclass constructors andcan’t be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors withfactory functions. 平台类型A public function/method returning an expression of a platform type must declare its Kotlin type explicitly: 1fun apiCall(): String = MyJavaApi.getProperty(\"name\") Any property (package-level or class-level) initialised with an expression of a platform type must declare its Kotlin type explicitly: 123class Person &#123; val name: String = MyJavaApi.getProperty(\"name\")&#125; A local value initialised with an expression of a platform type may or may not have a type declaration: 1234fun main(args: Array&lt;String&gt;) &#123; val name = MyJavaApi.getProperty(\"name\") println(name)&#125; 使用作用域函数 apply/with/run/also/letKotlin provides a variety of functions to execute a block of code in the context of a given object. To choose the correctfunction, consider the following: Are you calling methods on multiple objects in the block, or passing the instance of the context object as anargument? If you are, use one of the functions that allows you to access the context object as it,not this (also or let). Use also if the receiver is not used at all in the block. 1234567891011121314151617181920212223// Context object is 'it'class Baz &#123; var currentBar: Bar? val observable: Observable val foo = createBar().also &#123; currentBar = it // Accessing property of Baz observable.registerCallback(it) // Passing context object as argument &#125;&#125;// Receiver not used in the blockval foo = createBar().also &#123; LOG.info(\"Bar created\")&#125;// Context object is 'this'class Baz &#123; val foo: Bar = createBar().apply &#123; color = RED // Accessing only properties of Bar text = \"Foo\" &#125;&#125; What should the result of the call be? If the result needs to be the context object, use apply or also.If you need to return a value from the block, use with, let or run 123456789101112131415// Return value is context objectclass Baz &#123; val foo: Bar = createBar().apply &#123; color = RED // Accessing only properties of Bar text = \"Foo\" &#125;&#125;// Return value is block resultclass Baz &#123; val foo: Bar = createNetworkConnection().let &#123; loadBar() &#125;&#125; Is the context object nullable, or is it evaluated as a result of a call chain? If it is, use apply, let or run.Otherwise, use with or also. 1234567// Context object is nullableperson.email?.let &#123; sendEmail(it) &#125;// Context object is non-null and accessible directlywith(person) &#123; println(\"First name: $firstName, last name: $lastName\")&#125; 库的编码规范When writing libraries, it’s recommended to follow an additional set of rules to ensure API stability: Always explicitly specify member visibility (to avoid accidentally exposing declarations as public API) Always explicitly specify function return types and property types (to avoid accidentally changing the return typewhen the implementation changes) Provide KDoc comments for all public members, with the exception of overrides that do not require any new documentation(to support generating documentation for the library)","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"Getting Started","slug":"后端/Kotlin/Getting-Started","permalink":"http://oushiun.com/categories/后端/Kotlin/Getting-Started/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"习惯用法","slug":"kotlin/reference/idioms","date":"2018-05-15T08:42:56.000Z","updated":"2018-05-16T07:28:40.307Z","comments":true,"path":"kotlin/reference/idioms.html","link":"","permalink":"http://oushiun.com/kotlin/reference/idioms.html","excerpt":"一些在 Kotlin 中广泛使用的语法习惯，如果你有更喜欢的语法习惯或者风格，可以建一个 pull request 贡献！","text":"一些在 Kotlin 中广泛使用的语法习惯，如果你有更喜欢的语法习惯或者风格，可以建一个 pull request 贡献！ 创建 DTOs（POJOs/POCOs）1data class Customer(val name: String, val email: String) 会为 Customer 类提供以下功能： 所有属性的 getters （对于 var 定义的还有 setters） equals() hashCode() toString() copy() 所有属性的 component1()、 component2()……等等（参见数据类） 函数的默认参数1fun foo(a: Int = 0, b: String = \"\") &#123; …… &#125; 过滤 list1val positives = list.filter &#123; x -&gt; x &gt; 0 &#125; 或者可以更短: 1val positives = list.filter &#123; it &gt; 0 &#125; String 内插1println(\"Name $name\") 类型判断12345when (x) &#123; is Foo //-&gt; …… is Bar //-&gt; …… else //-&gt; ……&#125; 遍历 map/pair 型 list123for ((k, v) in map) &#123; println(\"$k -&gt; $v\")&#125; k、v 可以改成任意名字。 使用区间12345for (i in 1..100) &#123; …… &#125; // 闭区间：包含 100for (i in 1 until 100) &#123; …… &#125; // 半开区间：不包含 100for (x in 2..10 step 2) &#123; …… &#125;for (x in 10 downTo 1) &#123; …… &#125;if (x in 1..10) &#123; …… &#125; 只读 list1val list = listOf(\"a\", \"b\", \"c\") 只读 map1val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3) 访问 map12println(map[\"key\"])map[\"key\"] = value 延迟属性123val p: String by lazy &#123; // 计算该字符串&#125; 扩展函数123fun String.spaceToCamelCase() &#123; …… &#125;\"Convert this to camelcase\".spaceToCamelCase() 创建单例123object Resource &#123; val name = \"Name\"&#125; If not null 缩写123val files = File(\"Test\").listFiles()println(files?.size) If not null and else 缩写123val files = File(\"Test\").listFiles()println(files?.size ?: \"empty\") if null 执行一个语句12val values = ……val email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\") 在可能会空的集合中取第一元素12val emails = ... // 可能会是空集合val mainEmail = emails.firstOrNull() ?: \"\" if not null 执行代码12345val value = ……value?.let &#123; …… // 代码会执行到此处, 假如data不为null&#125; 映射可空值（如果非空的话）123val value = ……val mapped = value?.let &#123; transformValue(it) &#125; ?: defaultValueIfValueIsNull 返回 when 表达式12345678fun transform(color: String): Int &#123; return when (color) &#123; \"Red\" -&gt; 0 \"Green\" -&gt; 1 \"Blue\" -&gt; 2 else -&gt; throw IllegalArgumentException(\"Invalid color param value\") &#125;&#125; “try/catch”表达式123456789fun test() &#123; val result = try &#123; count() &#125; catch (e: ArithmeticException) &#123; throw IllegalStateException(e) &#125; // 使用 result&#125; “if”表达式123456789fun foo(param: Int) &#123; val result = if (param == 1) &#123; \"one\" &#125; else if (param == 2) &#123; \"two\" &#125; else &#123; \"three\" &#125;&#125; 返回类型为 Unit 的方法的 Builder 风格用法123fun arrayOfMinusOnes(size: Int): IntArray &#123; return IntArray(size).apply &#123; fill(-1) &#125;&#125; 单表达式函数1fun theAnswer() = 42 等价于 123fun theAnswer(): Int &#123; return 42&#125; 单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用： 123456fun transform(color: String): Int = when (color) &#123; \"Red\" -&gt; 0 \"Green\" -&gt; 1 \"Blue\" -&gt; 2 else -&gt; throw IllegalArgumentException(\"Invalid color param value\")&#125; 对一个对象实例调用多个方法 （with）12345678910111213141516class Turtle &#123; fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double)&#125;val myTurtle = Turtle()with(myTurtle) &#123; // 画一个 100 像素的正方形 penDown() for(i in 1..4) &#123; forward(100.0) turn(90.0) &#125; penUp()&#125; Java 7 的 try with resources1234val stream = Files.newInputStream(Paths.get(\"/some/file.txt\"))stream.buffered().reader().use &#123; reader -&gt; println(reader.readText())&#125; 对于需要泛型信息的泛型函数的适宜形式123456// public final class Gson &#123;// ……// public &lt;T&gt; T fromJson(JsonElement json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;// ……inline fun &lt;reified T: Any&gt; Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java) 使用可空布尔123456val b: Boolean? = ……if (b == true) &#123; ……&#125; else &#123; // `b` 是 false 或者 null&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"Getting Started","slug":"后端/Kotlin/Getting-Started","permalink":"http://oushiun.com/categories/后端/Kotlin/Getting-Started/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"基本语法","slug":"kotlin/reference/basic-syntax","date":"2018-05-15T04:29:00.000Z","updated":"2018-05-17T03:34:59.586Z","comments":true,"path":"kotlin/reference/basic-syntax.html","link":"","permalink":"http://oushiun.com/kotlin/reference/basic-syntax.html","excerpt":"定义包包的声明应处于源文件顶部： 12345package my.demoimport java.util.*// …… 目录与包的结构无需匹配：源代码可以在文件系统的任意位置。","text":"定义包包的声明应处于源文件顶部： 12345package my.demoimport java.util.*// …… 目录与包的结构无需匹配：源代码可以在文件系统的任意位置。 参见包。 定义函数带有两个 Int 参数、返回 Int 的函数： 12345678910//sampleStartfun sum(a: Int, b: Int): Int &#123; return a + b&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; print(\"sum of 3 and 5 is \") println(sum(3, 5))&#125; 将表达式作为函数体、返回值类型自动推断的函数： 1234567//sampleStartfun sum(a: Int, b: Int) = a + b//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"sum of 19 and 23 is $&#123;sum(19, 23)&#125;\")&#125; 函数返回无意义的值： 123456789//sampleStartfun printSum(a: Int, b: Int): Unit &#123; println(\"sum of $a and $b is $&#123;a + b&#125;\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; printSum(-1, 8)&#125; Unit 返回类型可以省略： 123456789//sampleStartfun printSum(a: Int, b: Int) &#123; println(\"sum of $a and $b is $&#123;a + b&#125;\")&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; printSum(-1, 8)&#125; 参见函数。 定义变量一次赋值（只读）的局部变量: 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val a: Int = 1 // 立即赋值 val b = 2 // 自动推断出 `Int` 类型 val c: Int // 如果没有初始值类型不能省略 c = 3 // 明确赋值//sampleEnd println(\"a = $a, b = $b, c = $c\")&#125; 可变变量： 1234567fun main(args: Array&lt;String&gt;) &#123;//sampleStart var x = 5 // 自动推断出 `Int` 类型 x += 1//sampleEnd println(\"x = $x\")&#125; 顶层变量： 123456789101112131415//sampleStartval PI = 3.14var x = 0fun incrementX() &#123; x += 1&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"x = $x; PI = $PI\") incrementX() println(\"incrementX()\") println(\"x = $x; PI = $PI\")&#125; 参见属性和字段。 注释正如 Java 和 JavaScript，Kotlin 支持行注释及块注释。 1234// 这是一个行注释/* 这是一个多行的 块注释。 */ 与 Java 不同的是，Kotlin 的块注释可以嵌套。 参见编写 Kotlin 代码文档 查看关于文档注释语法的信息。 使用字符串模板123456789101112fun main(args: Array&lt;String&gt;) &#123;//sampleStart var a = 1 // 模板中的简单名称： val s1 = \"a is $a\" a = 2 // 模板中的任意表达式： val s2 = \"$&#123;s1.replace(\"is\", \"was\")&#125;, but now is $a\"//sampleEnd println(s2)&#125; 参见字符串模板。 使用条件表达式12345678910111213//sampleStartfun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"max of 0 and 42 is $&#123;maxOf(0, 42)&#125;\")&#125; 使用 if 作为表达式: 1234567//sampleStartfun maxOf(a: Int, b: Int) = if (a &gt; b) a else b//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"max of 0 and 42 is $&#123;maxOf(0, 42)&#125;\")&#125; 参见if 表达式。 使用可空值及 null 检测当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。 如果 str 的内容不是数字返回 null： 123fun parseInt(str: String): Int? &#123; // ……&#125; 使用返回可空值的函数: 1234567891011121314151617181920212223242526fun parseInt(str: String): Int? &#123; return str.toIntOrNull()&#125;//sampleStartfun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) // 直接使用 `x * y` 会导致编译错误，因为他们可能为 null if (x != null &amp;&amp; y != null) &#123; // 在空检测后，x 和 y 会自动转换为非空值（non-nullable） println(x * y) &#125; else &#123; println(\"either '$arg1' or '$arg2' is not a number\") &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; printProduct(\"6\", \"7\") printProduct(\"a\", \"7\") printProduct(\"a\", \"b\")&#125; 或者 1234567891011121314151617181920212223242526272829fun parseInt(str: String): Int? &#123; return str.toIntOrNull()&#125;fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2)//sampleStart // …… if (x == null) &#123; println(\"Wrong number format in arg1: '$arg1'\") return &#125; if (y == null) &#123; println(\"Wrong number format in arg2: '$arg2'\") return &#125; // 在空检测后，x 和 y 会自动转换为非空值 println(x * y)//sampleEnd&#125;fun main(args: Array&lt;String&gt;) &#123; printProduct(\"6\", \"7\") printProduct(\"a\", \"7\") printProduct(\"99\", \"b\")&#125; 参见空安全。 使用类型检测及自动类型转换is 运算符检测一个表达式是否某类型的一个实例。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换： 123456789101112131415161718192021//sampleStartfun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // `obj` 在该条件分支内自动转换成 `String` return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; fun printLength(obj: Any) &#123; println(\"'$obj' string length is $&#123;getStringLength(obj) ?: \"... err, not a string\"&#125; \") &#125; printLength(\"Incomprehensibilities\") printLength(1000) printLength(listOf(Any()))&#125; 或者 123456789101112131415161718//sampleStartfun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // `obj` 在这一分支自动转换为 `String` return obj.length&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; fun printLength(obj: Any) &#123; println(\"'$obj' string length is $&#123;getStringLength(obj) ?: \"... err, not a string\"&#125; \") &#125; printLength(\"Incomprehensibilities\") printLength(1000) printLength(listOf(Any()))&#125; 甚至 1234567891011121314151617181920//sampleStartfun getStringLength(obj: Any): Int? &#123; // `obj` 在 `&amp;&amp;` 右边自动转换成 `String` 类型 if (obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; fun printLength(obj: Any) &#123; println(\"'$obj' string length is $&#123;getStringLength(obj) ?: \"... err, is empty or not a string at all\"&#125; \") &#125; printLength(\"Incomprehensibilities\") printLength(\"\") printLength(1000)&#125; 参见类 和 类型转换。 使用 for 循环12345678fun main(args: Array&lt;String&gt;) &#123;//sampleStart val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (item in items) &#123; println(item) &#125;//sampleEnd&#125; 或者 12345678fun main(args: Array&lt;String&gt;) &#123;//sampleStart val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (index in items.indices) &#123; println(\"item at $index is $&#123;items[index]&#125;\") &#125;//sampleEnd&#125; 参见 for 循环。 使用 while 循环12345678910fun main(args: Array&lt;String&gt;) &#123;//sampleStart val items = listOf(\"apple\", \"banana\", \"kiwifruit\") var index = 0 while (index &lt; items.size) &#123; println(\"item at $index is $&#123;items[index]&#125;\") index++ &#125;//sampleEnd&#125; 参见 while 循环。 使用 when 表达式123456789101112131415161718//sampleStartfun describe(obj: Any): String = when (obj) &#123; 1 -&gt; \"One\" \"Hello\" -&gt; \"Greeting\" is Long -&gt; \"Long\" !is String -&gt; \"Not a string\" else -&gt; \"Unknown\" &#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(describe(1)) println(describe(\"Hello\")) println(describe(1000L)) println(describe(2)) println(describe(\"other\"))&#125; 参见 when 表达式。 使用区间（range）使用 in 运算符来检测某个数字是否在指定区间内： 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val x = 10 val y = 9 if (x in 1..y+1) &#123; println(\"fits in range\") &#125;//sampleEnd&#125; 检测某个数字是否在指定区间外: 123456789101112fun main(args: Array&lt;String&gt;) &#123;//sampleStart val list = listOf(\"a\", \"b\", \"c\") if (-1 !in 0..list.lastIndex) &#123; println(\"-1 is out of range\") &#125; if (list.size !in list.indices) &#123; println(\"list size is out of valid list indices range too\") &#125;//sampleEnd&#125; 区间迭代: 1234567fun main(args: Array&lt;String&gt;) &#123;//sampleStart for (x in 1..5) &#123; print(x) &#125;//sampleEnd&#125; 或数列迭代： 1234567891011fun main(args: Array&lt;String&gt;) &#123;//sampleStart for (x in 1..10 step 2) &#123; print(x) &#125; println() for (x in 9 downTo 0 step 3) &#123; print(x) &#125;//sampleEnd&#125; 参见区间。 使用集合对集合进行迭代: 12345678fun main(args: Array&lt;String&gt;) &#123; val items = listOf(\"apple\", \"banana\", \"kiwifruit\")//sampleStart for (item in items) &#123; println(item) &#125;//sampleEnd&#125; 使用 in 运算符来判断集合内是否包含某实例： 123456789fun main(args: Array&lt;String&gt;) &#123; val items = setOf(\"apple\", \"banana\", \"kiwifruit\")//sampleStart when &#123; \"orange\" in items -&gt; println(\"juicy\") \"apple\" in items -&gt; println(\"apple is fine too\") &#125;//sampleEnd&#125; 使用 lambda 表达式来过滤（filter）和映射（map）集合： 12345678910fun main(args: Array&lt;String&gt;) &#123; val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")//sampleStart fruits .filter &#123; it.startsWith(\"a\") &#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;//sampleEnd&#125; 参见高阶函数及 Lambda 表达式。 创建基本类及其实例：123456789101112131415161718192021222324252627282930313233343536fun main(args: Array&lt;String&gt;) &#123;//sampleStart val rectangle = Rectangle(5.0, 2.0) // 不需要“new”关键字 val triangle = Triangle(3.0, 4.0, 5.0)//sampleEnd println(\"Area of rectangle is $&#123;rectangle.calculateArea()&#125;, its perimeter is $&#123;rectangle.perimeter&#125;\") println(\"Area of triangle is $&#123;triangle.calculateArea()&#125;, its perimeter is $&#123;triangle.perimeter&#125;\")&#125;abstract class Shape(val sides: List&lt;Double&gt;) &#123; val perimeter: Double get() = sides.sum() abstract fun calculateArea(): Double&#125;interface RectangleProperties &#123; val isSquare: Boolean&#125;class Rectangle( var height: Double, var length: Double) : Shape(listOf(height, length, height, length)), RectangleProperties &#123; override val isSquare: Boolean get() = length == height override fun calculateArea(): Double = height * length&#125;class Triangle( var sideA: Double, var sideB: Double, var sideC: Double) : Shape(listOf(sideA, sideB, sideC)) &#123; override fun calculateArea(): Double &#123; val s = perimeter / 2 return Math.sqrt(s * (s - sideA) * (s - sideB) * (s - sideC)) &#125;&#125; 参见类以及对象与实例。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"Getting Started","slug":"后端/Kotlin/Getting-Started","permalink":"http://oushiun.com/categories/后端/Kotlin/Getting-Started/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"Kotlin 1.2 的新特性","slug":"kotlin/reference/whatsnew1.2","date":"2018-05-15T04:15:24.000Z","updated":"2018-05-15T09:33:45.908Z","comments":true,"path":"kotlin/reference/whatsnew1.2.html","link":"","permalink":"http://oushiun.com/kotlin/reference/whatsnew1.2.html","excerpt":"多平台项目（实验性的）多平台项目是 Kotlin 1.2 中的一个新的实验性的功能，允许你在支持 Kotlin 的目标平台——JVM、JavaScript 以及（将来的）Native 之间重用代码。在多平台项目中，你有三种模块： 一个公共模块包含平台无关代码，以及无实现的依赖平台的 API 声明。 平台模块包含通用模块中的平台相关声明在指定平台的实现，以及其他平台相关代码。 常规模块针对指定的平台，既可以是平台模块的依赖，也可以依赖平台模块。","text":"多平台项目（实验性的）多平台项目是 Kotlin 1.2 中的一个新的实验性的功能，允许你在支持 Kotlin 的目标平台——JVM、JavaScript 以及（将来的）Native 之间重用代码。在多平台项目中，你有三种模块： 一个公共模块包含平台无关代码，以及无实现的依赖平台的 API 声明。 平台模块包含通用模块中的平台相关声明在指定平台的实现，以及其他平台相关代码。 常规模块针对指定的平台，既可以是平台模块的依赖，也可以依赖平台模块。 当你为指定平台编译多平台项目时，既会生成公共代码也会生成平台相关代码。 多平台项目支持的一个主要特点是可以通过预期声明与实际声明来表达公共代码对平台相关部分的依赖关系。一个预期声明指定一个 API（类、接口、注解、顶层声明等）。一个实际声明要么是该 API 的平台相关实现，要么是一个引用到在一个外部库中该 API 的一个既有实现的别名。这是一个示例： 在公共代码中： 12345678910111213// 预期平台相关 API:expect fun hello(world: String): Stringfun greet() &#123; // 该预期 API 的用法： val greeting = hello(\"multi-platform world\") println(greeting)&#125;expect class URL(spec: String) &#123; open fun getHost(): String open fun getPath(): String&#125; 在 JVM 平台代码中： 12345actual fun hello(world: String): String = \"Hello, $world, on the JVM platform!\"// 使用既有平台相关实现：actual typealias URL = java.net.URL 关于构建多平台项目的详细信息与步骤，请参见其documentation。 其他语言特性注解中的数组字面值自 Kotlin 1.2 起，注解的数组参数可以通过新的数组字面值语法传入，而无需使用 arrayOf 函数： 1234@CacheConfig(cacheNames = [\"books\", \"default\"])public class BookRepositoryImpl &#123; // ……&#125; 该数组字面值语法仅限于注解参数。 lateinit 顶层属性与局部变量lateinit 修饰符现在可以用于顶层属性与局部变量了。例如，后者可用于当一个 lambda 表达式作为构造函数参数传给一个对象时，引用另一个必须稍后定义的对象： 12345678910111213141516class Node&lt;T&gt;(val value: T, val next: () -&gt; Node&lt;T&gt;)fun main(args: Array&lt;String&gt;) &#123; //sampleStart // 三个节点的环： lateinit var third: Node&lt;Int&gt; val second = Node(2, next = &#123; third &#125;) val first = Node(1, next = &#123; second &#125;) third = Node(3, next = &#123; first &#125;) //sampleEnd val nodes = generateSequence(first) &#123; it.next() &#125; println(\"Values in the cycle: $&#123;nodes.take(7).joinToString &#123; it.value.toString() &#125;&#125;, ...\")&#125; 检查 lateinit 变量是否已初始化现在可以通过属性引用的 isInitialized 来检测该 lateinit var 是否已初始化： 123456789101112131415class Foo &#123; lateinit var lateinitVar: String fun initializationLogic() &#123; //sampleStart println(\"isInitialized before assignment: \" + this::lateinitVar.isInitialized) lateinitVar = \"value\" println(\"isInitialized after assignment: \" + this::lateinitVar.isInitialized) //sampleEnd &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Foo().initializationLogic()&#125; 内联函数带有默认函数式参数内联函数现在允许其内联函式数参数具有默认值： 123456789101112//sampleStartinline fun &lt;E&gt; Iterable&lt;E&gt;.strings(transform: (E) -&gt; String = &#123; it.toString() &#125;) = map &#123; transform(it) &#125;val defaultStrings = listOf(1, 2, 3).strings()val customStrings = listOf(1, 2, 3).strings &#123; \"($it)\" &#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"defaultStrings = $defaultStrings\") println(\"customStrings = $customStrings\")&#125; 源自显式类型转换的信息会用于类型推断Kotlin 编译器现在可将类型转换信息用于类型推断。如果你调用一个返回类型参数 T 的泛型方法并将返回值转换为指定类型 Foo，那么编译器现在知道对于本次调用需要绑定类型为 Foo。 这对于 Android 开发者来说尤为重要，因为编译器现在可以正确分析 Android API 级别 26 中的泛型 findViewById 调用： 1val button = findViewById(R.id.button) as Button 智能类型转换改进当一个变量有安全调用表达式与空检测赋值时，其智能转换现在也可以应用于安全调用接收者： 1234567891011121314151617181920212223fun countFirst(s: Any): Int &#123; //sampleStart val firstChar = (s as? CharSequence)?.firstOrNull() if (firstChar != null) return s.count &#123; it == firstChar &#125; // s: Any 会智能转换为 CharSequence val firstItem = (s as? Iterable&lt;*&gt;)?.firstOrNull() if (firstItem != null) return s.count &#123; it == firstItem &#125; // s: Any 会智能转换为 Iterable&lt;*&gt; //sampleEnd return -1&#125;fun main(args: Array&lt;String&gt;) &#123; val string = \"abacaba\" val countInString = countFirst(string) println(\"called on \\\"$string\\\": $countInString\") val list = listOf(1, 2, 3, 1, 2) val countInList = countFirst(list) println(\"called on $list: $countInList\")&#125; 智能转换现在也允许用于在 lambda 表达式中局部变量，只要这些局部变量仅在 lambda 表达式之前修改即可： 1234567891011121314fun main(args: Array&lt;String&gt;) &#123; val flag = args.size == 0 //sampleStart var x: String? = null if (flag) x = \"Yahoo!\" run &#123; if (x != null) &#123; println(x.length) // x 会智能转换为 String &#125; &#125; //sampleEnd&#125; 支持 ::foo 作为 this::foo 的简写现在写绑定到 this 成员的可调用引用可以无需显式接收者，即 ::foo 取代 this:: foo。这也使在引用外部接收者的成员的 lambda 表达式中使用可调用引用更加方便。 阻断性变更：try 块后可靠智能转换Kotlin 以前将 try 块中的赋值语句用于块后的智能转换，这可能会破坏类型安全与空安全并引发运行时故障。这个版本修复了该问题，使智能转换更加严格，但可能会破坏一些依靠这种智能转换的代码。 如果要切换到旧版智能转换行为，请传入回退标志 -Xlegacy-smart-cast-after-try 作为编译器参数。该参数会在 Kotlin 1.3 中弃用。 弃用：数据类弃用 copy当从已具有签名相同的 copy 函数的类型派生数据类时，为数据类生成的 copy 实现使用超类型的默认值，这导致反直觉行为，或者导致运行时失败，如果超类型中没有默认参数的话。 导致 copy 冲突的继承在 Kotlin 1.2 中已弃用并带有警告，而在 Kotlin 1.3 中将会是错误。 弃用：枚举条目中的嵌套类型由于初始化逻辑的问题，已弃用在枚举条目内部定义一个非 inner class 的嵌套类。这在 Kotlin 1.2 中会引起警告，而在 Kotlin 1.3 中会成为错误。 弃用：vararg 单个命名参数为了与注解中的数组字面值保持一致，向一个命名参数形式的 vararg 参数传入单个项目的用法（foo(items = i)）已被弃用。请使用伸展操作符连同相应的数组工厂函数： 1foo(items = *intArrayOf(1)) 在这种情况下有一项防止性能下降的优化可以消除冗余的数组创建。单参数形式在 Kotlin 1.2 中会产生警告，而在 Kotlin 1.3 中会放弃。 弃用：扩展 Throwable 的泛型类的内部类继承自 Throwable 的泛型类的内部类可能会在 throw-catch 场景中违反类型安全性，因此已弃用，在 Kotlin 1.2 中会是警告，而在 Kotlin 1.3 中会是错误。 弃用：修改只读属性的幕后字段通过在自定义 getter 中赋值 field = …… 来修改只读属性的幕后字段的用法已被弃用，在 Kotlin 1.2 中会是警告，而在 Kotlin 1.3 中会是错误。 标准库Kotlin 标准库构件与拆分包Kotlin 标准库现在完全兼容 Java 9 的模块系统，它禁止拆分包（多个 jar 文件声明的类在同一包中）。为了支持这点，我们引入了新的 kotlin-stdlib-jdk7 与 kotlin-stdlib-jdk8，它们取代了旧版的 kotlin-stdlib-jre7 与 kotlin-stdlib-jre8。 在 Kotlin 看来新的构件中的声明在相同的包名内，而在 Java 看来有不同的包名。因此，切换到新的构件无需修改任何源代码。 确保与新的模块系统兼容的另一处变更是在 kotlin-reflect 库中删除了 kotlin.reflect 包中弃用的声明。如果你正在使用它们，你需要切换到使用 kotlin.reflect.full 包中的声明，自 Kotlin 1.1 起就支持这个包了。 windowed、chunked、zipWithNext用于 Iterable&lt;T&gt;、 Sequence&lt;T&gt; 与 CharSequence 的新的扩展覆盖了这些应用场景：缓存或批处理（chunked）、 滑动窗口与计算滑动均值（windowed）以及处理成对的后续条目（zipWithNext）： 12345678910111213141516171819fun main(args: Array&lt;String&gt;) &#123; //sampleStart val items = (1..9).map &#123; it * it &#125; val chunkedIntoLists = items.chunked(4) val points3d = items.chunked(3) &#123; (x, y, z) -&gt; Triple(x, y, z) &#125; val windowed = items.windowed(4) val slidingAverage = items.windowed(4) &#123; it.average() &#125; val pairwiseDifferences = items.zipWithNext &#123; a, b -&gt; b - a &#125; //sampleEnd println(\"items: $items\\n\") println(\"chunked into lists: $chunkedIntoLists\") println(\"3D points: $points3d\") println(\"windowed by 4: $windowed\") println(\"sliding average by 4: $slidingAverage\") println(\"pairwise differences: $pairwiseDifferences\")&#125; fill、replaceAll、shuffle/shuffled添加了一些用于操作列表的扩展函数：MutableList 的 fill、replaceAll 与 shuffle，以及只读 List 的 shuffled： 1234567891011121314fun main(args: Array&lt;String&gt;) &#123; //sampleStart val items = (1..5).toMutableList() items.shuffle() println(\"Shuffled items: $items\") items.replaceAll &#123; it * 2 &#125; println(\"Items doubled: $items\") items.fill(5) println(\"Items filled with 5: $items\") //sampleEnd&#125; kotlin-stdlib 中的数学运算为满足由来已久的需求，Kotlin 1.2 添加了 JVM 与 JS 公用的用于数学运算的 kotlin.math API，包含以下内容： 常量：PI 与 E； 三角函数：cos、 sin、 tan 及其反函数：acos、 asin、 atan、 atan2； 双曲函数：cosh、 sinh、 tanh 及其反函数：acosh、 asinh、 atanh 指数函数：pow（扩展函数）、 sqrt、 hypot、 exp、 expm1； 对数函数：log、 log2、 log10、 ln、 ln1p； 取整: ceil、 floor、 truncate、 round（奇进偶舍）函数； roundToInt、 roundToLong（四舍五入）扩展函数； 符号与绝对值： abs 与 sign 函数； absoluteValue 与 sign 扩展属性； withSign 扩展函数； 两个数的最值函数：max 与 min； 二进制表示： ulp 扩展属性； nextUp、 nextDown、 nextTowards 扩展函数； toBits、 toRawBits、 Double.fromBits（这些在 kotlin 包中）。 这些函数同样也有 Float 参数版本（但不包括常量）。 用于 BigInteger 与 BigDecimal 的操作符与转换Kotlin 1.2 引入了一些使用 BigInteger 与 BigDecimal 运算以及由其他数字类型创建它们的函数。具体如下： toBigInteger 用于 Int 与 Long； toBigDecimal 用于 Int、 Long、 Float、 Double 以及 BigInteger； 算术与位运算操作符函数： 二元操作符 +、 -、 *、 /、 % 以及中缀函数 and、 or、 xor、 shl、 shr； 一元操作符 -、 ++、 -- 以及函数 inv。 浮点数到比特的转换添加了用于将 Double 及 Float 与其比特表示形式相互转换的函数： toBits 与 toRawBits 对于 Double 返回 Long 而对于 Float 返回 Int； Double.fromBits 与 Float.fromBits 用于有相应比特表示形式创建浮点数。 正则表达式现在可序列化kotlin.text.Regex 类现在已经是 Serializable 的了并且可用在可序列化的继承结构中。 如果可用，Closeable.use 会调用 Throwable.addSuppressed当在其他异常之后关闭资源期间抛出一个异常，Closeable.use 函数会调用 Throwable.addSuppressed。 要启用这个行为，需要依赖项中有 kotlin-stdlib-jdk7。 JVM 后端构造函数调用规范化自 1.0 版起，Kotlin 就已支持带有复杂控制流的表达式，诸如 try-catch 表达式以及内联函数。根据 Java 虚拟机规范这样的代码是有效的。不幸的是，当这样的表达式出现在构造函数调用的参数中时，一些字节码处理工具不能很好地处理这种代码。 为了缓解这种字节码处理工具用户的这一问题，我们添加了一个命令行选项（-Xnormalize-constructor-calls=模式），告诉编译器为这样的构造过程生成更接近 Java 的字节码。其中模式是下列之一： disable（默认）——以与 Kotlin 1.0 即 1.1 相同的方式生成字节码； enable——为构造函数调用生成类似 Java 的字节码。 这可能会改变类加载与初始化的顺序； preserve-class-initialization——为构造函数调用生成类似 Java 的字节码，并确保类初始化顺序得到保留。这可能会影响应用程序的整体性能；仅用在多个类之间共享一些复杂状态并在类初始化时更新的场景中。 “人工”解决办法是将具有控制流的子表达式的值存储在变量中，而不是直接在调用参数内对其求值。这与 -Xnormalize-constructor-calls=enable 类似。 Java 默认方法调用在 Kotlin 1.2 之前，针对 JVM 1.6 的接口成员覆盖 Java 默认方法会产生一个关于超类型调用的警告：Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with &#39;-jvm-target 1.8&#39;（“针对 JVM 1.6 的 Java 默认方法的超类型调用已弃用，请使用‘-jvm-target 1.8’重新编译”）。在 Kotlin 1.2 中，这是一个错误 ，因此这样的代码都需要针对 JVM 1.8 编译。 阻断性变更：平台类型 x.equals(null) 的一致行为在映射到 Java 原生类型（Int!、 Boolean!、 Short!、 Long!、 Float!、 Double!、 Char!）的平台类型上调用 x.equals(null)，当 x 为 null 时错误地返回了 true。自 Kotlin 1.2 起，在平台类型的空值上调用 x.equals(……) 都会抛出 NPE （但 x == ... 不会）。 要返回到 1.2 之前的行为，请将标志 -Xno-exception-on-explicit-equals-for-boxed-null 传给编译器。 阻断性变更：修正平台 null 透过内联扩展接收者逃逸在平台类型的空值上调用内联扩展函数并没有检测接收者是否为 null，因而允许 null 逃逸到其他代码中。Kotlin 1.2 在调用处强制执行这项检测，如果接收者为空就抛出异常。 要切换到旧版行为，请将回退标志 -Xno-receiver-assertions 传给编译器。 JavaScript 后端默认启用 TypedArrays 支持将 Kotlin 原生数组（如 IntArray、 DoubleArray 等）翻译为 JavaScript 有类型数组的 JS 有类型数组支持之前是选择性加入的功能，现在已默认启用。 工具警告作为错误编译器现在提供一个将所有警告视为错误的选项。可在命令行中使用 -Werror，或者在 Gradle 中使用以下代码片段： 123compileKotlin &#123; kotlinOptions.allWarningsAsErrors = true&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"Kotlin 1.1 的新特性","slug":"kotlin/reference/whatsnew1.1","date":"2018-05-15T03:23:01.000Z","updated":"2018-05-15T09:33:42.467Z","comments":true,"path":"kotlin/reference/whatsnew1.1.html","link":"","permalink":"http://oushiun.com/kotlin/reference/whatsnew1.1.html","excerpt":"协程（实验性的）Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 协程实际上是一个轻量级的线程，可以挂起并稍后恢复。协程通过挂起函数支持：对这样的函数的调用可能会挂起协程，并启动一个新的协程，我们通常使用匿名挂起函数（即挂起 lambda 表达式）。","text":"协程（实验性的）Kotlin 1.1 的关键新特性是协程，它带来了 future/await、 yield 以及类似的编程模式的支持。Kotlin 的设计中的关键特性是协程执行的实现是语言库的一部分，而不是语言的一部分，所以你不必绑定任何特定的编程范式或并发库。 协程实际上是一个轻量级的线程，可以挂起并稍后恢复。协程通过挂起函数支持：对这样的函数的调用可能会挂起协程，并启动一个新的协程，我们通常使用匿名挂起函数（即挂起 lambda 表达式）。 我们来看看在外部库 kotlinx.coroutines 中实现的 async/await： 12345678910111213141516// 在后台线程池中运行该代码fun asyncOverlay() = async(CommonPool) &#123; // 启动两个异步操作 val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // 然后应用叠加到两个结果 applyOverlay(original.await(), overlay.await())&#125;// 在 UI 上下文中启动新的协程launch(UI) &#123; // 等待异步叠加完成 val image = asyncOverlay().await() // 然后在 UI 中显示 showImage(image)&#125; 这里，async { …… } 启动一个协程，当我们使用 await() 时，挂起协程的执行，而执行正在等待的操作，并且在等待的操作完成时恢复（可能在不同的线程上） 。 标准库通过 yield 和 yieldAll 函数使用协程来支持惰性生成序列。在这样的序列中，在取回每个元素之后挂起返回序列元素的代码块，并在请求下一个元素时恢复。这里有一个例子： 1234567891011121314151617import kotlin.coroutines.experimental.*fun main(args: Array&lt;String&gt;) &#123;//sampleStart val seq = buildSequence &#123; for (i in 1..5) &#123; // 产生一个 i 的平方 yield(i * i) &#125; // 产生一个区间 yieldAll(26..28) &#125; // 输出该序列 println(seq.toList())//sampleEnd&#125; 更多信息请参见协程文档及教程。 请注意，协程目前还是一个实验性的功能，这意味着 Kotlin 团队不承诺在最终的 1.1 版本时保持该功能的向后兼容性。 其他语言功能类型别名类型别名允许你为现有类型定义备用名称。这对于泛型类型（如集合）以及函数类型最有用。这里有几个例子： 123456789101112131415161718192021222324252627//sampleStarttypealias OscarWinners = Map&lt;String, String&gt;fun countLaLaLand(oscarWinners: OscarWinners) = oscarWinners.count &#123; it.value.contains(\"La La Land\") &#125;// 请注意，类型名称（初始名和类型别名）是可互换的：fun checkLaLaLandIsTheBestMovie(oscarWinners: Map&lt;String, String&gt;) = oscarWinners[\"Best picture\"] == \"La La Land\"//sampleEndfun oscarWinners(): OscarWinners &#123; return mapOf( \"Best song\" to \"City of Stars (La La Land)\", \"Best actress\" to \"Emma Stone (La La Land)\", \"Best picture\" to \"Moonlight\" /* …… */)&#125;fun main(args: Array&lt;String&gt;) &#123; val oscarWinners = oscarWinners() val laLaLandAwards = countLaLaLand(oscarWinners) println(\"LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.\") val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners) println(\"LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie\")&#125; 更详细信息请参阅其 KEEP。 已绑定的可调用引用现在可以使用 :: 操作符来获取指向特定对象实例的方法或属性的成员引用。以前这只能用 lambda 表达式表示。这里有一个例子： 12345678//sampleStartval numberRegex = \"\\\\d+\".toRegex()val numbers = listOf(\"abc\", \"123\", \"456\").filter(numberRegex::matches)//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"Result is $numbers\")&#125; 更详细信息请参阅其 KEEP。 密封类和数据类Kotlin 1.1 删除了一些对 Kotlin 1.0 中已存在的密封类和数据类的限制。现在你可以在同一个文件中的任何地方定义一个密封类的子类，而不只是以作为密封类嵌套类的方式。数据类现在可以扩展其他类。这可以用来友好且清晰地定义一个表达式类的层次结构： 123456789101112131415161718//sampleStartsealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun eval(expr: Expr): Double = when (expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN&#125;val e = eval(Sum(Const(1.0), Const(2.0)))//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(\"e is $e\") // 3.0&#125; 更详细信息请参阅其文档或者密封类及数据类的 KEEP。 lambda 表达式中的解构现在可以使用解构声明语法来解开传递给 lambda 表达式的参数。这里有一个例子： 123456789101112fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(1 to \"one\", 2 to \"two\") // 之前 println(map.mapValues &#123; entry -&gt; val (key, value) = entry \"$key -&gt; $value!\" &#125;) // 现在 println(map.mapValues &#123; (key, value) -&gt; \"$key -&gt; $value!\" &#125;)//sampleEnd&#125; 更详细信息请参阅其文档及其 KEEP。 下划线用于未使用的参数对于具有多个参数的 lambda 表达式，可以使用 _ 字符替换不使用的参数的名称： 1234567fun main(args: Array&lt;String&gt;) &#123; val map = mapOf(1 to \"one\", 2 to \"two\")//sampleStart map.forEach &#123; _, value -&gt; println(\"$value!\") &#125;//sampleEnd&#125; 这也适用于解构声明： 12345678910data class Result(val value: Any, val status: String)fun getResult() = Result(42, \"ok\").also &#123; println(\"getResult() returns $it\") &#125;fun main(args: Array&lt;String&gt;) &#123;//sampleStart val (_, status) = getResult()//sampleEnd println(\"status is '$status'\")&#125; 更详细信息请参阅其 KEEP。 数字字面值中的下划线正如在 Java 8 中一样，Kotlin 现在允许在数字字面值中使用下划线来分隔数字分组： 1234567891011//sampleStartval oneMillion = 1_000_000val hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010//sampleEndfun main(args: Array&lt;String&gt;) &#123; println(oneMillion) println(hexBytes.toString(16)) println(bytes.toString(2))&#125; 更详细信息请参阅其 KEEP。 对于属性的更短语法对于没有自定义访问器、或者将 getter 定义为表达式主体的属性，现在可以省略属性的类型： 12345678910//sampleStartdata class Person(val name: String, val age: Int) &#123; val isAdult get() = age &gt;= 20 // 属性类型推断为 “Boolean”&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; val akari = Person(\"Akari\", 26) println(\"$akari.isAdult = $&#123;akari.isAdult&#125;\")&#125; 内联属性访问器如果属性没有幕后字段，现在可以使用 inline 修饰符来标记该属性访问器。这些访问器的编译方式与内联函数相同。 12345678910//sampleStartpublic val &lt;T&gt; List&lt;T&gt;.lastIndex: Int inline get() = this.size - 1//sampleEndfun main(args: Array&lt;String&gt;) &#123; val list = listOf('a', 'b') // 其 getter 会内联 println(\"Last index of $list is $&#123;list.lastIndex&#125;\")&#125; 你也可以将整个属性标记为 inline——这样修饰符应用于两个访问器。 更详细信息请参阅其文档及其 KEEP。 局部委托属性现在可以对局部变量使用委托属性语法。一个可能的用途是定义一个延迟求值的局部变量： 123456789101112131415161718import java.util.Randomfun needAnswer() = Random().nextBoolean()fun main(args: Array&lt;String&gt;) &#123;//sampleStart val answer by lazy &#123; println(\"Calculating the answer...\") 42 &#125; if (needAnswer()) &#123; // 返回随机值 println(\"The answer is $answer.\") // 此时计算出答案 &#125; else &#123; println(\"Sometimes no answer is the answer...\") &#125;//sampleEnd&#125; 更详细信息请参阅其 KEEP。 委托属性绑定的拦截对于委托属性，现在可以使用 provideDelegate 操作符拦截委托到属性之间的绑定。例如，如果我们想要在绑定之前检查属性名称，我们可以这样写： 123456789101112131415class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate(thisRef: MyUI, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, property.name) …… // 属性创建 &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;class MyUI &#123; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 方法在创建 MyUI 实例期间将会为每个属性调用，并且可以立即执行必要的验证。 更详细信息请参阅其文档。 泛型枚举值访问现在可以用泛型的方式来对枚举类的值进行枚举： 1234567891011//sampleStartenum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE&#125; 对于 DSL 中隐式接收者的作用域控制@DslMarker 注解允许限制来自 DSL 上下文中的外部作用域的接收者的使用。考虑那个典型的 HTML 构建器示例： 12345table &#123; tr &#123; td &#123; +\"Text\" &#125; &#125;&#125; 在 Kotlin 1.0 中，传递给 td 的 lambda 表达式中的代码可以访问三个隐式接收者：传递给 table、tr 和 td 的。 这允许你调用在上下文中没有意义的方法——例如在 td 里面调用 tr，从而在 &lt;td&gt; 中放置一个 &lt;tr&gt; 标签。 在 Kotlin 1.1 中，你可以限制这种情况，以使只有在 td 的隐式接收者上定义的方法会在传给 td 的 lambda 表达式中可用。你可以通过定义标记有 @DslMarker 元注解的注解并将其应用于标记类的基类。 更详细信息请参阅其文档及其 KEEP。 rem 操作符mod 操作符现已弃用，而使用 rem 取代。动机参见这个问题。 标准库字符串到数字的转换在 String 类中有一些新的扩展，用来将它转换为数字，而不会在无效数字上抛出异常：String.toIntOrNull(): Int?、 String.toDoubleOrNull(): Double? 等。 1val port = System.getenv(\"PORT\")?.toIntOrNull() ?: 80 还有整数转换函数，如 Int.toString()、 String.toInt()、 String.toIntOrNull()，每个都有一个带有 radix 参数的重载，它允许指定转换的基数（2 到 36）。 onEach()onEach 是一个小、但对于集合和序列很有用的扩展函数，它允许对操作链中的集合/序列的每个元素执行一些操作，可能带有副作用。对于迭代其行为像 forEach 但是也进一步返回可迭代实例。 对于序列它返回一个包装序列，它在元素迭代时延迟应用给定的动作。 1234inputDir.walk() .filter &#123; it.isFile &amp;&amp; it.name.endsWith(\".txt\") &#125; .onEach &#123; println(\"Moving $it to $outputDir\") &#125; .forEach &#123; moveFile(it, File(outputDir, it.toRelativeString(inputDir))) &#125; also()、takeIf() 和 takeUnless()这些是适用于任何接收者的三个通用扩展函数。 also 就像 apply：它接受接收者、做一些动作、并返回该接收者。二者区别是在 apply 内部的代码块中接收者是 this，而在 also 内部的代码块中是 it（并且如果你想的话，你可以给它另一个名字）。当你不想掩盖来自外部作用域的 this 时这很方便： 123456789101112131415161718192021class Block &#123; lateinit var content: String&#125;//sampleStartfun Block.copy() = Block().also &#123; it.content = this.content&#125;//sampleEnd// 使用“apply”代替fun Block.copy1() = Block().apply &#123; this.content = this@copy1.content&#125;fun main(args: Array&lt;String&gt;) &#123; val block = Block().apply &#123; content = \"content\" &#125; val copy = block.copy() println(\"Testing the content was copied:\") println(block.content == copy.content)&#125; takeIf 就像单个值的 filter。它检查接收者是否满足该谓词，并在满足时返回该接收者否则不满足时返回 null。结合 elvis-操作符和及早返回，它允许编写如下结构： 12val outDirFile = File(outputDir.path).takeIf &#123; it.exists() &#125; ?: return false// 对现有的 outDirFile 做些事情 12345678910111213fun main(args: Array&lt;String&gt;) &#123; val input = \"Kotlin\" val keyword = \"in\"//sampleStart val index = input.indexOf(keyword).takeIf &#123; it &gt;= 0 &#125; ?: error(\"keyword not found\") // 对输入字符串中的关键字索引做些事情，鉴于它已找到//sampleEnd println(\"'$keyword' was found in '$input'\") println(input) println(\" \".repeat(index) + \"^\")&#125; takeUnless 与 takeIf 相同，只是它采用了反向谓词。当它 _不_ 满足谓词时返回接收者，否则返回 null。因此，上面的示例之一可以用 takeUnless 重写如下： 1val index = input.indexOf(keyword).takeUnless &#123; it &lt; 0 &#125; ?: error(\"keyword not found\") 当你有一个可调用的引用而不是 lambda 时，使用也很方便： 123456789101112private fun testTakeUnless(string: String) &#123;//sampleStart val result = string.takeUnless(String::isEmpty)//sampleEnd println(\"string = \\\"$string\\\"; result = \\\"$result\\\"\")&#125;fun main(args: Array&lt;String&gt;) &#123; testTakeUnless(\"\") testTakeUnless(\"abc\")&#125; groupingBy()此 API 可以用于按照键对集合进行分组，并同时折叠每个组。 例如，它可以用于计算文本中字符的频率： 123456789101112fun main(args: Array&lt;String&gt;) &#123; val words = \"one two three four five six seven eight nine ten\".split(' ')//sampleStart val frequencies = words.groupingBy &#123; it.first() &#125;.eachCount()//sampleEnd println(\"Counting first letters: $frequencies.\") // 另一种方式是使用“groupBy”和“mapValues”创建一个中间的映射， // 而“groupingBy”的方式会即时计数。 val groupBy = words.groupBy &#123; it.first() &#125;.mapValues &#123; (_, list) -&gt; list.size &#125; println(\"Comparing the result with using 'groupBy': $&#123;groupBy == frequencies&#125;.\")&#125; Map.toMap() 和 Map.toMutableMap()这俩函数可以用来简易复制映射： 123class ImmutablePropertyBag(map: Map&lt;String, Any&gt;) &#123; private val mapCopy = map.toMap()&#125; Map.minus(key)运算符 plus 提供了一种将键值对添加到只读映射中以生成新映射的方法，但是没有一种简单的方法来做相反的操作：从映射中删除一个键采用不那么直接的方式如 Map.filter() 或 Map.filterKeys()。现在运算符 minus 填补了这个空白。有 4 个可用的重载：用于删除单个键、键的集合、键的序列和键的数组。 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(\"key\" to 42) val emptyMap = map - \"key\"//sampleEnd println(\"map: $map\") println(\"emptyMap: $emptyMap\")&#125; minOf() 和 maxOf()这些函数可用于查找两个或三个给定值中的最小和最大值，其中值是原生数字或 Comparable 对象。每个函数还有一个重载，它接受一个额外的 Comparator 实例，如果你想比较自身不可比的对象的话。 1234567891011fun main(args: Array&lt;String&gt;) &#123;//sampleStart val list1 = listOf(\"a\", \"b\") val list2 = listOf(\"x\", \"y\", \"z\") val minSize = minOf(list1.size, list2.size) val longestList = maxOf(list1, list2, compareBy &#123; it.size &#125;)//sampleEnd println(\"minSize = $minSize\") println(\"longestList = $longestList\")&#125; 类似数组的列表实例化函数类似于 Array 构造函数，现在有创建 List 和 MutableList 实例的函数，并通过调用 lambda 表达式来初始化每个元素： 123456789fun main(args: Array&lt;String&gt;) &#123;//sampleStart val squares = List(10) &#123; index -&gt; index * index &#125; val mutable = MutableList(10) &#123; 0 &#125;//sampleEnd println(\"squares: $squares\") println(\"mutable: $mutable\")&#125; Map.getValue()Map 上的这个扩展函数返回一个与给定键相对应的现有值，或者抛出一个异常，提示找不到该键。如果该映射是用 withDefault 生成的，这个函数将返回默认值，而不是抛异常。 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123;//sampleStart val map = mapOf(\"key\" to 42) // 返回不可空 Int 值 42 val value: Int = map.getValue(\"key\") val mapWithDefault = map.withDefault &#123; k -&gt; k.length &#125; // 返回 4 val value2 = mapWithDefault.getValue(\"key2\") // map.getValue(\"anotherKey\") // &lt;- 这将抛出 NoSuchElementException//sampleEnd println(\"value is $value\") println(\"value2 is $value2\")&#125; 抽象集合这些抽象类可以在实现 Kotlin 集合类时用作基类。对于实现只读集合，有 AbstractCollection、 AbstractList、 AbstractSet 和 AbstractMap，而对于可变集合，有 AbstractMutableCollection、 AbstractMutableList、 AbstractMutableSet 和 AbstractMutableMap。在 JVM 上，这些抽象可变集合从 JDK 的抽象集合继承了大部分的功能。 数组处理函数标准库现在提供了一组用于逐个元素操作数组的函数：比较（contentEquals 和 contentDeepEquals），哈希码计算（contentHashCode 和 contentDeepHashCode），以及转换成一个字符串（contentToString 和 contentDeepToString）。它们都支持 JVM（它们作为 java.util.Arrays 中的相应函数的别名）和 JS（在 Kotlin 标准库中提供实现）。 1234567fun main(args: Array&lt;String&gt;) &#123;//sampleStart val array = arrayOf(\"a\", \"b\", \"c\") println(array.toString()) // JVM 实现：类型及哈希乱码 println(array.contentToString()) // 良好格式化为列表//sampleEnd&#125; JVM 后端Java 8 字节码支持Kotlin 现在可以选择生成 Java 8 字节码（命令行选项 -jvm-target 1.8 或者 Ant/Maven/Gradle 中的相应选项）。目前这并不改变字节码的语义（特别是，接口和 lambda 表达式中的默认方法的生成与 Kotlin 1.0 中完全一样），但我们计划在以后进一步使用它。 Java 8 标准库支持现在有支持在 Java 7 和 8 中新添加的 JDK API 的标准库的独立版本。如果你需要访问新的 API，请使用 kotlin-stdlib-jre7 和 kotlin-stdlib-jre8 maven 构件，而不是标准的 kotlin-stdlib。这些构件是在 kotlin-stdlib 之上的微小扩展，它们将它作为传递依赖项带到项目中。 字节码中的参数名Kotlin 现在支持在字节码中存储参数名。这可以使用命令行选项 -java-parameters 启用。 常量内联编译器现在将 const val 属性的值内联到使用它们的位置。 可变闭包变量用于在 lambda 表达式中捕获可变闭包变量的装箱类不再具有 volatile 字段。此更改提高了性能，但在一些罕见的使用情况下可能导致新的竞争条件。如果受此影响，你需要提供自己的同步机制来访问变量。 javax.scripting 支持Kotlin 现在与javax.script API（JSR-223）集成。其 API 允许在运行时求值代码段： 123val engine = ScriptEngineManager().getEngineByExtension(\"kts\")!!engine.eval(\"val x = 3\")println(engine.eval(\"x + 2\")) // 输出 5 关于使用 API 的示例项目参见这里。 kotlin.reflect.full为 Java 9 支持准备，在 kotlin-reflect.jar 库中的扩展函数和属性已移动到 kotlin.reflect.full 包中。旧包（kotlin.reflect）中的名称已弃用，将在 Kotlin 1.2 中删除。请注意，核心反射接口（如 KClass）是 Kotlin 标准库（而不是 kotlin-reflect）的一部分，不受移动影响。 JavaScript 后端统一的标准库Kotlin 标准库的大部分目前可以从代码编译成 JavaScript 来使用。特别是，关键类如集合（ArrayList、 HashMap 等）、异常（IllegalArgumentException 等）以及其他几个关键类（StringBuilder、 Comparator）现在都定义在 kotlin 包下。在 JVM 平台上，一些名称是相应 JDK 类的类型别名，而在 JS 平台上，这些类在 Kotlin 标准库中实现。 更好的代码生成JavaScript 后端现在生成更加可静态检查的代码，这对 JS 代码处理工具（如 minifiers、 optimisers、 linters 等）更加友好。 external 修饰符如果你需要以类型安全的方式在 Kotlin 中访问 JavaScript 实现的类，你可以使用 external 修饰符写一个 Kotlin 声明。（在 Kotlin 1.0 中，使用了 @native 注解。）与 JVM 目标平台不同，JS 平台允许对类和属性使用 external 修饰符。例如，可以按以下方式声明 DOM Node 类： 123456789external class Node &#123; val firstChild: Node fun appendChild(child: Node): Node fun removeChild(child: Node): Node // 等等&#125; 改进的导入处理现在可以更精确地描述应该从 JavaScript 模块导入的声明。如果在外部声明上添加 @JsModule(&quot;＜模块名＞&quot;) 注解，它会在编译期间正确导入到模块系统（CommonJS 或 AMD）。例如，使用 CommonJS，该声明会通过 require(……) 函数导入。此外，如果要将声明作为模块或全局 JavaScript 对象导入，可以使用 @JsNonModule 注解。 例如，以下是将 JQuery 导入 Kotlin 模块的方法： 123456789external interface JQuery &#123; fun toggle(duration: Int = definedExternally): JQuery fun click(handler: (Event) -&gt; Unit): JQuery&#125;@JsModule(\"jquery\")@JsNonModule@JsName(\"$\")external fun jquery(selector: String): JQuery 在这种情况下，JQuery 将作为名为 jquery 的模块导入。或者，它可以用作 $-对象，这取决于 Kotlin 编译器配置使用哪个模块系统。 你可以在应用程序中使用如下所示的这些声明： 12345fun main(args: Array&lt;String&gt;) &#123; jquery(\".toggle-button\").click &#123; jquery(\".toggle-panel\").toggle(300) &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"Kotlin/Native","slug":"kotlin/reference/native-overview","date":"2018-05-15T03:18:04.000Z","updated":"2018-05-15T09:33:22.950Z","comments":true,"path":"kotlin/reference/native-overview.html","link":"","permalink":"http://oushiun.com/kotlin/reference/native-overview.html","excerpt":"Kotlin/Native 是一种将 Kotlin 编译为没有任何虚拟机的原生二进制文件的技术。它包含基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 运行时库的原生实现 Kotlin/Native 主要为允许在不希望或不可能使用虚拟机的平台（如 iOS、嵌入式领域等）编译、或者开发人员需要生成不需要额外运行时的合理大小的独立程序而设计的。","text":"Kotlin/Native 是一种将 Kotlin 编译为没有任何虚拟机的原生二进制文件的技术。它包含基于 LLVM 的 Kotlin 编译器后端以及 Kotlin 运行时库的原生实现 Kotlin/Native 主要为允许在不希望或不可能使用虚拟机的平台（如 iOS、嵌入式领域等）编译、或者开发人员需要生成不需要额外运行时的合理大小的独立程序而设计的。 Kotlin/Native 完全支持与原生代码的互操作。对于平台库，相应互操作库已可以开箱即用。对于其他库，我们提供了一个由 C 语言头文件生成互操作库的工具，完全支持所有 C 语言功能。在 macOS 与 iOS 上，还支持与 Objective-C 代码互操作。 Kotlin/Native 目前还在开发中；可以试用其预览版。 Kotlin/Native 的 IDE 支持已作为 CLion 及 AppCode 的插件提供，both require the plugin to be installed via Plugins | Install JetBrains plugin… in the IDE preferences。 目标平台Kotlin/Native 目前支持以下平台： Windows（目前只支持 x86_64） Linux（x86_64、 arm32、 MIPS、 MIPS little endian） MacOS（x86_64） iOS（只支持 arm64） Android（arm32 与 arm64） WebAssembly（只支持 wasm32) 示例项目我们已经构建了一些示例项目来展示 Kotlin/Native 的可能性： Kotlin/Native GitHub 版本库包含一些示例项目； KotlinConf Spinner 应用是一个简单的跨平台移动端多人游戏，完全使用 Kotlin/Native 构建，由以下组件组成： 后端，使用 SQLite 来做数据存储并暴露一个 REST/JSON API； iOS 与 Android 移动客户端，使用 OpenGL； 一个基于 WebAssembly 的浏览器前端用于查看游戏分数。 KotlinConf 应用是一个具有基于 UIKit 的 UI 的 iOS 应用程序，展示了 Kotlin/Native 与 Objective-C 互操作的便利性。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"Native","slug":"Native","permalink":"http://oushiun.com/tags/Native/"}]},{"title":"使用 Kotlin 进行 JavaScript 开发","slug":"kotlin/reference/js-overview","date":"2018-05-15T02:47:22.000Z","updated":"2018-05-15T09:33:19.643Z","comments":true,"path":"kotlin/reference/js-overview.html","link":"","permalink":"http://oushiun.com/kotlin/reference/js-overview.html","excerpt":"Kotlin 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现。目前的实现目标是 ECMAScript 5.1，但也有最终目标为 ECMAScript 2015 的计划。 当你选择 JavaScript 目标时，作为项目一部分的任何 Kotlin 代码以及 Kotlin 附带的标准库都会转换为 JavaScript。然而，这不包括使用的 JDK 和任何 JVM 或 Java 框架或库。任何不是 Kotlin 的文件会在编译期间忽略掉。 Kotlin 编译器努力遵循以下目标： 提供最佳大小的输出 提供可读的 JavaScript 输出 提供与现有模块系统的互操作性 在标准库中提供相同的功能，无论是 JavaScript 还是 JVM 目标（尽最大可能程度）。","text":"Kotlin 提供了 JavaScript 作为目标平台的能力。它通过将 Kotlin 转换为 JavaScript 来实现。目前的实现目标是 ECMAScript 5.1，但也有最终目标为 ECMAScript 2015 的计划。 当你选择 JavaScript 目标时，作为项目一部分的任何 Kotlin 代码以及 Kotlin 附带的标准库都会转换为 JavaScript。然而，这不包括使用的 JDK 和任何 JVM 或 Java 框架或库。任何不是 Kotlin 的文件会在编译期间忽略掉。 Kotlin 编译器努力遵循以下目标： 提供最佳大小的输出 提供可读的 JavaScript 输出 提供与现有模块系统的互操作性 在标准库中提供相同的功能，无论是 JavaScript 还是 JVM 目标（尽最大可能程度）。 如何使用你可能希望在以下情景中将 Kotlin 编译为 JavaScript： 创建面向客户端 JavaScript 的 Kotlin 代码 与 DOM 元素交互。Kotlin 提供了一系列静态类型的接口来与文档对象模型（Document Object Model）交互，允许创建和更新 DOM 元素。 与图形如 WebGL 交互。你可以使用 Kotlin 在网页上用 WebGL 创建图形元素。 创建面向服务器端 JavaScript 的 Kotlin 代码 使用服务器端技术。你可以使用 Kotlin 与服务器端 JavaScript（如 Node.js）进行交互 Kotlin 可以与现有的第三方库和框架（如 jQuery 或 ReactJS）一起使用。要使用强类型API 访问第三方框架，可以使用 ts2kt 工具将 TypeScript 定义从 Definitely Typed类型定义仓库转换为 Kotlin。或者，你可以使用动态类型访问任何框架，而无需强类型。 JetBrains 特地为 React 社区开发并维护了几个工具：React bindings 以及 Create React Kotlin App。后者可以帮你开始使用 Kotlin 构建 React 应用程序而无需构建配置。 Kotlin 兼容 CommonJS、AMD 和 UMD，直截了当与不同的模块系统交互。 Kotlin 转 JavaScript 入门要了解如何开始使用 JavaScript 平台的 Kotlin，请参考其教程。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://oushiun.com/tags/JavaScript/"}]},{"title":"使用 Kotlin 进行 Android 开发","slug":"kotlin/reference/android-overview","date":"2018-05-15T02:31:26.000Z","updated":"2018-05-15T09:32:36.005Z","comments":true,"path":"kotlin/reference/android-overview.html","link":"","permalink":"http://oushiun.com/kotlin/reference/android-overview.html","excerpt":"Kotlin 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制： 兼容性：Kotlin 与 JDK 6 完全兼容，保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统。 性能：由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。 互操作性：Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库。这包括注解处理，所以数据绑定和 Dagger 也是一样。 占用：Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。在实际应用程序中，Kotlin 运行时只增加几百个方法以及 .apk 文件不到 100K 大小。 编译时长：Kotlin 支持高效的增量编译，所以对于清理构建会有额外的开销，增量构建通常与 Java 一样快或者更快。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换有助于迈出第一步。","text":"Kotlin 非常适合开发 Android 应用程序，将现代语言的所有优势带入 Android 平台而不会引入任何新的限制： 兼容性：Kotlin 与 JDK 6 完全兼容，保障了 Kotlin 应用程序可以在较旧的 Android 设备上运行而无任何问题。Kotlin 工具在 Android Studio 中会完全支持，并且兼容 Android 构建系统。 性能：由于非常相似的字节码结构，Kotlin 应用程序的运行速度与 Java 类似。随着 Kotlin 对内联函数的支持，使用 lambda 表达式的代码通常比用 Java 写的代码运行得更快。 互操作性：Kotlin 可与 Java 进行 100％ 的互操作，允许在 Kotlin 应用程序中使用所有现有的 Android 库。这包括注解处理，所以数据绑定和 Dagger 也是一样。 占用：Kotlin 具有非常紧凑的运行时库，可以通过使用 ProGuard 进一步减少。在实际应用程序中，Kotlin 运行时只增加几百个方法以及 .apk 文件不到 100K 大小。 编译时长：Kotlin 支持高效的增量编译，所以对于清理构建会有额外的开销，增量构建通常与 Java 一样快或者更快。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换有助于迈出第一步。 Kotlin 用于 Android 的案例学习Kotlin 已被一些大公司成功采用，其中一些公司分享了他们的经验： Pinterest 已经成功地将 Kotlin 引入了他们的应用程序中，每个月有 1 亿 5 千万人使用。 Basecamp 的 Android 应用程序是 100％ Kotlin 代码，他们报告了程序员幸福的巨大差异，以及工作质量和速度的巨大改善。 Keepsafe 的 App Lock 应用程序也已转换为 100％ Kotlin，使源代码行数减少 30％、方法数减少 10％。 用于 Android 开发的工具Kotlin 团队为 Android 开发提供了一套超越标准语言功能的工具： Kotlin Android 扩展是一个编译器扩展，可以让你摆脱代码中的 findViewById() 调用，并将其替换为合成的编译器生成的属性。 Anko 是一个提供围绕 Android API 的 Kotlin 友好的包装器的库，以及一个可以用 Kotlin 代码替换布局 .xml 文件的 DSL。 下一步 下载并安装 Android Studio 3.0，其中包含开箱即用的 Kotlin 支持。 按照 Android 与 Kotlin 入门教程创建你的第一个 Kotlin 应用程序。 关于更深入的介绍，请查看本站的参考文档。 另一个很好的资源是 Kotlin for Android Developers，这本书会引导你逐步完成在 Kotlin 中创建真正的 Android 应用程序的过程。 检出 Google 的 Kotlin 写的示例项目。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"},{"name":"Android","slug":"Android","permalink":"http://oushiun.com/tags/Android/"}]},{"title":"使用 Kotlin 进行服务器端开发","slug":"kotlin/reference/server-overview","date":"2018-05-15T01:22:38.000Z","updated":"2018-05-15T09:33:36.434Z","comments":true,"path":"kotlin/reference/server-overview.html","link":"","permalink":"http://oushiun.com/kotlin/reference/server-overview.html","excerpt":"Kotlin 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码，同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线： 表现力：Kotlin 的革新式语言功能，例如支持类型安全的构建器和委托属性，有助于构建强大而易于使用的抽象。 可伸缩性：Kotlin 对协程的支持有助于构建服务器端应用程序，伸缩到适度的硬件要求以应对大量的客户端。 互操作性：Kotlin 与所有基于 Java 的框架完全兼容，可以让你保持熟悉的技术栈，同时获得更现代化语言的优势。 迁移：Kotlin 支持大型代码库从 Java 到 Kotlin 逐步迁移。你可以开始用 Kotlin 编写新代码，同时系统中较旧部分继续用 Java。 工具：除了很棒的 IDE 支持之外，Kotlin 还为 IntelliJ IDEA Ultimate 的插件提供了框架特定的工具（例如Spring）。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换器有助于迈出第一步。","text":"Kotlin 非常适合开发服务器端应用程序，允许编写简明且表现力强的代码，同时保持与现有基于 Java 的技术栈的完全兼容性以及平滑的学习曲线： 表现力：Kotlin 的革新式语言功能，例如支持类型安全的构建器和委托属性，有助于构建强大而易于使用的抽象。 可伸缩性：Kotlin 对协程的支持有助于构建服务器端应用程序，伸缩到适度的硬件要求以应对大量的客户端。 互操作性：Kotlin 与所有基于 Java 的框架完全兼容，可以让你保持熟悉的技术栈，同时获得更现代化语言的优势。 迁移：Kotlin 支持大型代码库从 Java 到 Kotlin 逐步迁移。你可以开始用 Kotlin 编写新代码，同时系统中较旧部分继续用 Java。 工具：除了很棒的 IDE 支持之外，Kotlin 还为 IntelliJ IDEA Ultimate 的插件提供了框架特定的工具（例如Spring）。 学习曲线：对于 Java 开发人员，Kotlin 入门很容易。包含在 Kotlin 插件中的自动 Java 到 Kotlin 的转换器有助于迈出第一步。 使用 Kotlin 进行服务器端开发的框架 Spring 利用 Kotlin 的语言功能提供更简洁的 API，从版本 5.0 开始。在线项目生成器允许用 Kotlin 快速生成一个新项目。 Vert.x 是在 JVM 上构建响应式 Web 应用程序的框架，为 Kotlin 提供了专门支持，包括完整的文档。 Ktor 是由 JetBrains 构建的 Kotlin 原生 Web 框架，利用协程实现高可伸缩性，并提供易于使用且合乎惯用法的 API。 kotlinx.html 是可在 Web 应用程序中用于构建 HTML 的 DSL。它可以作为传统模板系统（如 JSP 和 FreeMarker）的替代品。 通过相应 Java 驱动程序进行持久化的可用选项包括直接 JDBC 访问、JPA 以及使用 NoSQL 数据库。对于 JPA，kotlin-jpa 编译器插件使 Kotlin 编译的类适应框架的要求。 部署 Kotlin 服务器端应用程序Kotlin 应用程序可以部署到支持 Java Web 应用程序的任何主机，包括 Amazon Web Services、Google Cloud Platform 等。 要在 Heroku 上部署 Kotlin 应用程序，可以按照 Heroku 官方教程来做。 AWS Labs 提供了一个示例项目，展示了 Kotlin 编写 AWS Lambda 函数的使用。 Kotlin 用于服务器端的用户Corda 是一个开源的分布式分类帐平台，由各大银行提供支持，完全由 Kotlin 构建。 JetBrains 账户，负责 JetBrains 整个许可证销售和验证过程的系统 100％ 由 Kotlin 编写，自 2015 年生产运行以来，一直没有重大问题。 下一步 使用 Http Servlet 创建 Web 应用程序 及 使用 Spring Boot 创建 RESTful Web 服务教程将向你展示如何在 Kotlin 中构建和运行非常小的 Web 应用程序。 关于更深入的介绍，请查看本站的参考文档 及 Kotlin 心印。","categories":[{"name":"后端","slug":"后端","permalink":"http://oushiun.com/categories/后端/"},{"name":"Kotlin","slug":"后端/Kotlin","permalink":"http://oushiun.com/categories/后端/Kotlin/"},{"name":"概述","slug":"后端/Kotlin/概述","permalink":"http://oushiun.com/categories/后端/Kotlin/概述/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://oushiun.com/tags/Kotlin/"}]},{"title":"ContOS 7 安装 BBR","slug":"centos-install-bbr","date":"2018-05-12T11:02:51.000Z","updated":"2018-05-15T09:33:49.732Z","comments":true,"path":"centos-install-bbr.html","link":"","permalink":"http://oushiun.com/centos-install-bbr.html","excerpt":"Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。","text":"Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。 CentOS 7.3 yum 系统更新（更新到 CentOS 7.3） 1yum update 查看系统版本 1cat /etc/redhat-release 输出如下（release 数值大于 7.3 即可），则表示已升级到 7.3 1CentOS Linux release 7.3.1611 (Core) 安装 elrepo 并升级内核 123rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install kernel-ml -y 正常情况下将输出如下信息： 1234567891011121314151617Transaction Summary================================================================================Install 1 PackageTotal download size: 39 MInstalled size: 169 MDownloading packages:kernel-ml-4.9.0-1.el7.elrepo.x86_64.rpm | 39 MB 00:00Running transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum. Installing : kernel-ml-4.9.0-1.el7.elrepo.x86_64 1/1 Verifying : kernel-ml-4.9.0-1.el7.elrepo.x86_64 1/1Installed: kernel-ml.x86_64 0:4.9.0-1.el7.elrepoComplete! 更新 grub 文件并重启（reboot 后，ssh 会断开，稍等一会儿重新连接） 123egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\'grub2-set-default 0reboot 开机后查看内核是否已更换为 4.9 1uname -r 输出如下内容则表示内核 4.9 已经启动了（数值大于 4.9 即可） 14.9.0-1.el7.elrepo.x86_64 CentOS 7.4导入 elrepo 软件源的 GPG 公钥 1rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 导入 elrepo 软件源 说明：该地址可以自动下载该源的最新的软件列表，无需修改地址。 1rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 下载并安装新的内核 启用软件源并下载安装最新稳定版内核 1yum -y --enablerepo=elrepo-kernel install kernel-ml 设定 Grub 默认启动新内核 说明：如果手动修改过 Grub 的配置文件，以下命令可能无法执行成功。请自行修改 Grub 配置文件。 1grub2-set-default 0 使用新的内核重启 1reboot 检查设置 &amp; 删除旧的内核 查看当前系统的内核版本号 1uname -r 如果输出是 4.10 以上的版本，说明安装成功。 14.14.13-1.el7.elrepo.x86_64 删除旧内核 说明：删除旧内核的目的是为了防止 yum 更新旧版内核之后覆盖了 grub 默认启动项 1yum -y remove kernel kernel-tools 开启 BBR1vim /etc/sysctl.conf 添加如下内容 12net.core.default_qdisc = fqnet.ipv4.tcp_congestion_control = bbr 加载系统参数（正常情况下会输出我们之前加入的内容） 1sysctl -p 验证 bbr 是否已经开启 a.若 1sysctl net.ipv4.tcp_available_congestion_control 返回 1net.ipv4.tcp_available_congestion_control = bbr cubic reno 则成功 b.若 1lsmod | grep bbr 返回形如如下形式的信息即成功。 12tcp_bbr 16384 1tcp_bbr 20480 0","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"BBR","slug":"BBR","permalink":"http://oushiun.com/tags/BBR/"},{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"}]},{"title":"Css 盒子模型","slug":"css3/css-box-model","date":"2018-05-10T14:46:15.000Z","updated":"2018-05-15T09:56:37.439Z","comments":true,"path":"css3/css-box-model.html","link":"","permalink":"http://oushiun.com/css3/css-box-model.html","excerpt":"盒模型(box model)是 CSS 中的一个重要概念，它是元素大小的呈现方式。需要记住的是：”every element in web design is a rectangular box”。如图：","text":"盒模型(box model)是 CSS 中的一个重要概念，它是元素大小的呈现方式。需要记住的是：”every element in web design is a rectangular box”。如图： CSS3 中新增了一种盒模型计算方式：box-sizing 熟悉。盒模型默认的值是 content-box, 新增的值是 padding-box 和 border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度 Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度 Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度 Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度 Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度 Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度 Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) margin 叠加外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。 一般来说， 垂直外边距叠加有三种情况： 元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。 相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。 包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。 参考资料CSS-TRICKS:The CSS Box Model CSS Magic: The Box","categories":[{"name":"前端","slug":"前端","permalink":"http://oushiun.com/categories/前端/"},{"name":"Css3","slug":"前端/Css3","permalink":"http://oushiun.com/categories/前端/Css3/"}],"tags":[{"name":"Box Model","slug":"Box-Model","permalink":"http://oushiun.com/tags/Box-Model/"}]},{"title":"CentOS 搭建 shadowsocks","slug":"centos-install-shadowsocks","date":"2018-05-09T14:20:38.000Z","updated":"2018-05-15T09:33:57.812Z","comments":true,"path":"centos-install-shadowsocks.html","link":"","permalink":"http://oushiun.com/centos-install-shadowsocks.html","excerpt":"Shadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。","text":"Shadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得 GFW 没法将由它传输的资料和其他普通资料区分开来，也就不能干扰我们访问那些「不存在」的网站了。 安装 shadowsocks安装 pipPip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。 123wget https://bootstrap.pypa.io/get-pip.pypython get-pip.pypip -V #pip 10.0.1 from /usr/lib/python2.7/site-packages/pip (python 2.7) 通过 pip 安装 shadowsocks12pip install --upgrade pippip install shadowsocks 配置 shadowsocks1234567891011# vi /etc/shadowsocks.json&#123; \"server\":\"x.x.x.x\", #你的 ss 服务器 ip \"server_port\":0, #你的 ss 服务器端口 \"local_address\": \"127.0.0.1\", #本地ip \"local_port\":0, #本地端口 \"password\":\"password\", #连接 ss 密码 \"timeout\":300, #等待超时 \"method\":\"aes-256-cfb\", #加密方式 \"workers\": 1 #工作线程数&#125; systemctl 设置1234567891011121314# vi /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid --log-file /var/log/shadowsocks.log -c /etc/shadowsocks.json -d startRestart=on-abort[Install]WantedBy=multi-user.target 配置 firwall 规则输入以下命令开启一个端口，如果不是 9002 端口，修改成自己需要添加的端口（–permanent 永久生效，没有此参数重启后失效）。 1firewall-cmd --zone=public --add-port=9002/tcp --permanent 添加端口后系统返回 success 说明添加成功。这个时候需要重新载入 firewall，输入以下命令，返回 success 后此端口就可使用 1firewall-cmd --reload shadowsocks 其他配置1234567891011121314151617181920212223242526272829ssserver -husage: ssserver [OPTION]...A fast tunnel proxy that helps you bypass firewalls.You can supply configurations via either config file or command line arguments.Proxy options: -c CONFIG path to config file -s SERVER_ADDR server address, default: 0.0.0.0 -p SERVER_PORT server port, default: 8388 -k PASSWORD password -m METHOD encryption method, default: aes-256-cfb -t TIMEOUT timeout in seconds, default: 300 --fast-open use TCP_FASTOPEN, requires Linux 3.7+ --workers WORKERS number of workers, available on Unix/Linux --forbidden-ip IPLIST comma seperated IP list forbidden to connect --manager-address ADDR optional server manager UDP address, see wikiGeneral options: -h, --help show this help message and exit -d start/stop/restart daemon mode --pid-file PID_FILE pid file for daemon mode --log-file LOG_FILE log file for daemon mode --user USER username to run as -v, -vv verbose mode -q, -qq quiet mode, only show warnings/errors --version show version informationOnline help: &lt;https://github.com/shadowsocks/shadowsocks&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://oushiun.com/tags/shadowsocks/"}]},{"title":"Markdown","slug":"markdown","date":"2018-05-09T01:41:47.000Z","updated":"2018-05-15T09:34:12.176Z","comments":true,"path":"markdown.html","link":"","permalink":"http://oushiun.com/markdown.html","excerpt":"A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF).","text":"A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF). Block ElementsParagraphs and Line BreaksParagraphsHTML Tag: &lt;p&gt; One or more blank lines. (A blank line is a line containing nothing but spaces or tabs is considered blank.) Code: This will be inline. This is second paragraph. Preview: This will beinline. This is second paragraph. Line BreaksHTML Tag: &lt;br /&gt; End a line with two or more spaces. Code: This will be not inline. Preview: This will be notinline. HeadersMarkdown supports two styles of headers, Setext and atx. SetextHTML Tags: &lt;h1&gt;, &lt;h2&gt; “Underlined” using equal signs (=) as &lt;h1&gt; and dashes (-) as &lt;h2&gt; in any number. Code: This is an H1 ============= This is an H2 ------------- Preview: This is an H1This is an H2 atxHTML Tags: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; Uses 1-6 hash characters (#) at the start of the line, corresponding to &lt;h1&gt; - &lt;h6&gt;. Code: # This is an H1 ## This is an H2 ###### This is an H6 Preview: This is an H1This is an H2This is an H6 Optionally, you may “close” atx-style headers. The closing hashes don’t need to match the number of hashes used to open the header. Code: # This is an H1 # ## This is an H2 ## ### This is an H3 ###### Preview: This is an H1This is an H2This is an H3 BlockquotesHTML Tag: &lt;blockquote&gt; Markdown uses email-style &gt; characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;. Code: &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. Preview: This is the first level of quoting. This is nested blockquote. Back to the first level. Blockquotes can contain other Markdown elements, including headers, lists, and code blocks. Code: &gt; ## This is a header. &gt; &gt; 1. This is the first list item. &gt; 2. This is the second list item. &gt; &gt; Here&apos;s some example code: &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); Preview: This is a header. This is the first list item. This is the second list item. Here’s some example code: return shell_exec(&quot;echo $input | $markdown_script&quot;); ListsMarkdown supports ordered (numbered) and unordered (bulleted) lists. UnorderedHTML Tag: &lt;ul&gt; Unordered lists use asterisks (*), pluses (+), and hyphens (-). Code: * Red * Green * Blue Preview: Red Green Blue is equivalent to: Code: + Red + Green + Blue and: Code: - Red - Green - Blue OrderedHTML Tag: &lt;ol&gt; Ordered lists use numbers followed by periods: Code: 1. Bird 2. McHale 3. Parish Preview: Bird McHale Parish It’s possible to trigger an ordered list by accident, by writing something like this: Code: 1986. What a great season. Preview: What a great season. You can backslash-escape (\\) the period: Code: 1986\\. What a great season. Preview: 1986. What a great season. IndentedBlockquoteTo put a blockquote within a list item, the blockquote’s &gt; delimiters need to be indented: Code: * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. Preview: A list item with a blockquote: This is a blockquoteinside a list item. Code BlockTo put a code block within a list item, the code block needs to be indented twice — 8 spaces or two tabs: Code: * A list item with a code block: &lt;code goes here&gt; Preview: A list item with a code block: &lt;code goes here&gt; Nested ListCode: * A * A1 * A2 * B * C Preview: A A1 A2 B C Code BlocksHTML Tag: &lt;pre&gt; Indent every line of the block by at least 4 spaces or 1 tab. Code: This is a normal paragraph: This is a code block. Preview: This is a normal paragraph: This is a code block. A code block continues until it reaches a line that is not indented (or the end of the article). Within a code block, ampersands (&amp;) and angle brackets (&lt; and &gt;) are automatically converted into HTML entities. Code: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Preview: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block. Fenced Code BlocksJust wrap your code in ``` ```` (as shown below) and you won't need to indent it by four spaces.1234Code: Here&apos;s an example: function test() { console.log(&quot;notice the blank line before this function?&quot;); } 123Preview:***Here&apos;s an example: function test() { console.log(“notice the blank line before this function?”);}12345678910***#### Syntax HighlightingIn your fenced block, add an optional language identifier and we&apos;ll run it through syntax highlighting ([Support Languages](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml)).Code: ```ruby require &apos;redcarpet&apos; markdown = Redcarpet.new(&quot;Hello World!&quot;) puts markdown.to_html Preview: 123require 'redcarpet'markdown = Redcarpet.new(\"Hello World!\")puts markdown.to_html Horizontal RulesHTML Tag: &lt;hr /&gt;Places three or more hyphens (-), asterisks (*), or underscores (_) on a line by themselves. You may use spaces between the hyphens or asterisks. Code: * * * *** ***** - - - --------------------------------------- ___ Preview: TableHTML Tag: &lt;table&gt; It’s an extension. Separates column by pipe (|) and header by dashes (-), and uses colon (:) for alignment. The outer pipes (|) and alignment are optional. There are 3 delimiters each cell at least for separating header. Code:12345678910111213| Left | Center | Right || :----- | :------: | ------: || aaa | bbb | ccc || ddd | eee | fff | | | A | B | | | | --- | --- | | | | 123 | 456 | |A |B--|--12|45 Preview: Left Center Right aaa bbb ccc ddd eee fff A B 123 456 A B 12 45 Span ElementsLinksHTML Tag: &lt;a&gt; Markdown supports two style of links: inline and reference. InlineInline link format like this: [Link Text](URL &quot;Title&quot;) Title is optional. Code: This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. Preview: This is an example inline link. This link has no title attribute. If you’re referring to a local resource on the same server, you can use relative paths: Code: See my [About](/about/) page for details. Preview: See my About page for details. ReferenceYou could predefine link references. Format like this: [id]: URL &quot;Title&quot; Title is also optional. And the you refer the link, format like this: [Link Text][id] Code: [id]: http://example.com/ &quot;Optional Title Here&quot; This is [an example][id] reference-style link. Preview: This is an example reference-style link. That is: Square brackets containing the link identifier (not case sensitive, optionally indented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; The link URL may, optionally, be surrounded by angle brackets. optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses. The following three link definitions are equivalent: Code: [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) [foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; Uses an empty set of square brackets, the link text itself is used as the name. Code: [Google]: http://google.com/ [Google][] Preview: Google EmphasisHTML Tags: &lt;em&gt;, &lt;strong&gt; Markdown treats asterisks (*) and underscores (_) as indicators of emphasis. One delimiter will be &lt;em&gt;; *double delimiters will be &lt;strong&gt;. Code: *single asterisks* _single underscores_ **double asterisks** __double underscores__ Preview: single asterisks single underscores double asterisks double underscores But if you surround an * or _ with spaces, it’ll be treated as a literal asterisk or underscore. You can backslash escape it: Code: \\*this text is surrounded by literal asterisks\\* Preview: *this text is surrounded by literal asterisks* CodeHTML Tag: &lt;code&gt; Wraps it with backtick quotes (`). Code: Use the `printf()` function. Preview: Use the printf() function. To include a literal backtick character within a code span, you can use multiple backticks as the opening and closing delimiters: Code: ``There is a literal backtick (`) here.`` Preview: There is a literal backtick (`) here. The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span: Code: A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` Preview: A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` ImagesHTML Tag: &lt;img /&gt; Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference. InlineInline image syntax looks like this: ![Alt text](URL &quot;Title&quot;) Title is optional. Code: ![Alt text](https://static.oushiun.com/blog/img/desk.jpg) ![Alt text](https://static.oushiun.com/blog/img/desk.jpg &quot;Optional title&quot;) Preview: That is: An exclamation mark: !; followed by a set of square brackets, containing the alt attribute text for the image; followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes. ReferenceReference-style image syntax looks like this: ![Alt text][id] Code: [img id]: https://static.oushiun.com/blog/img/desk.jpg &quot;Optional title attribute&quot; ![Alt text][img id] Preview: StrikethroughHTML Tag: &lt;del&gt; It’s an extension. GFM adds syntax to strikethrough text. Code:1~~Mistaken text.~~ Preview: Mistaken text. MiscellaneousAutomatic LinksMarkdown supports a shortcut style for creating “automatic” links for URLs and email addresses: simply surround the URL or email address with angle brackets. Code: &lt;http://example.com/&gt; &lt;address@example.com&gt; Preview: http://example.com/ &#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d; GFM will autolink standard URLs. Code:1https://github.com/emn178/markdown Preview: https://github.com/emn178/markdown Backslash EscapesMarkdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown’s formatting syntax. Code: \\*literal asterisks\\* Preview: *literal asterisks* Markdown provides backslash escapes for the following characters: Code: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark Inline HTMLFor any markup that is not covered by Markdown’s syntax, you simply use HTML itself. There’s no need to preface it or delimit it to indicate that you’re switching from Markdown to HTML; you just use the tags. Code: This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. Preview: This is a regular paragraph. Foo This is another regular paragraph. Note that Markdown formatting syntax is not processed within block-level HTML tags. Unlike block-level HTML tags, Markdown syntax is processed within span-level tags. Code: &lt;span&gt;**Work**&lt;/span&gt; &lt;div&gt; **No Work** &lt;/div&gt; Preview: Work No Work","categories":[{"name":"工具","slug":"工具","permalink":"http://oushiun.com/categories/工具/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://oushiun.com/tags/Markdown/"}]},{"title":"CentOS 搭建 jetbrains 破解服务器","slug":"centos-install-jetbrains-server","date":"2018-05-08T09:18:37.000Z","updated":"2018-05-15T09:34:00.532Z","comments":true,"path":"centos-install-jetbrains-server.html","link":"","permalink":"http://oushiun.com/centos-install-jetbrains-server.html","excerpt":"CentOS 搭建 jetbrains 破解服务器","text":"CentOS 搭建 jetbrains 破解服务器 安装步骤 检查是否安装了 vsftpd 1rpm -qa |grep vsftpd Linux 系统：CentOS 7 x86_64 1cat /etc/os-release 通过 yum 来安装 vsftpd 1yum -y install vsftpd 设置为开机启动 123456systemctl enable vsftpdsystemctl start vsftpd #启动vsftpd命令systemctl stop vsftpd #停止vsftpd命令systemctl status vsftpd #查看vsftpd状态systemctl restart vsftpd #重启vsftpd命令 修改配置文件 1vi /etc/vsftpd/vsftpd.conf 添加用户及额外配置 启用 root 用户进入 /etc/vsftpd 目录下修改 ::ftpusers:: &amp; ::user_list::将 root 用户注释 # 开放 21 端口 1firewall-cmd --zone=public --add-port=21/tcp --permanent 12345678yum install firewalld #安装firewalld 防火墙systemctl start firewalld.service #开启防火墙systemctl stop firewalld.service #关闭防火墙systemctl enable firewalld.service #开机自动启动systemctl disable firewalld.service #禁止开机制动启动firewall-cmd --state #running 表示运行firewall-cmd --reload #重新载入以生效firewall-cmd --complete-reload #更新规则，重启服务 上传文件下载IntelliJ IDEA License Server v1.6(当前使用是 v1.6，新版本还请及时关注lanyus) 解压到 某个目录下(任意即可), IntelliJIDEALicenseServer 目录下涵盖了很多平台(mac linux windows)。当前服务器是 x86_64 GNU/Linux，so 给 IntelliJIDEALicenseServer_linux_amd64 赋可执行权限 1chmod +x IntelliJIDEALicenseServer_linux_amd64 安装配置 Nginx 通过 yum 安装 Nginx 12yum install epel-releaseyum install nginx 常用命令 123systemctl start nginxsystemctl enable nginxsystemctl status nginx 配置防火墙 123firewall-cmd --zone=public --permanent --add-service=httpfirewall-cmd --zone=public --permanent --add-service=httpsfirewall-cmd --reload 测试 Nginx 是否正常访问http://SERVER_DOMAIN_NAME_OR_IP 修改 Nginx 配置文件 1234567891011121314151617#vi /usr/local/nginx/conf/nginx.confserver &#123; listen 80; server_name idea.oushiun.com; root /usr/local/nginx/html; location / &#123; proxy_pass http://127.0.0.1:1027; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; access_log /dev/null; error_log /dev/null;&#125; 注意事项：需要展示破解地址文档，通过 nginx 反向代理需要将 IntelliJIDEALicenseServer.html 放在/目录，如果是通过直接运行脚本需要和脚本在同一目录。 systemd 设置 12345678910111213141516# vim /etc/systemd/system/intellij.service[Unit]Description= IntelliJIDEALicenseServe ServiceAfter=network.target[Service]ExecStart=/root/jetbrains/IntelliJIDEALicenseServer_linux_amd64PrivateTmp=true[Install]WantedBy=default.target# systemctl daemon-reload # 重载# systemctl start intellij # 启动# systemctl enable intellij # 开机启动# systemctl disable intellij # 撤销开机启动 IntelliJIDEALicenseServer 帮助 123456789./IntelliJIDEALicenseServer_linux_amd64 -h-l string 绑定的host，基本默认 bind on host (default \"0.0.0.0\") -p int 监听端口，建议改下 port (default 1027) -prolongationPeriod string 过期时间 prolongationPeriod (default \"607875500\") -u string 当未设置-u参数，且计算机用户名为^[a-zA-Z0-9]+$时，使用计算机用户名作为idea用户名 username (default \"ilanyu\")","categories":[{"name":"软件","slug":"软件","permalink":"http://oushiun.com/categories/软件/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://oushiun.com/tags/CentOS/"},{"name":"jetbrains","slug":"jetbrains","permalink":"http://oushiun.com/tags/jetbrains/"}]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2018-05-08T02:32:25.448Z","updated":"2018-05-15T09:34:34.227Z","comments":true,"path":"hello-hexo.html","link":"","permalink":"http://oushiun.com/hello-hexo.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://oushiun.com/categories/其他/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://oushiun.com/tags/Hexo/"}]}]}